  TCSH(1)  

TCSH(1)

FreeBSD General Commands Manual

TCSH(1)

[名称](#__u540D___u79F0_)
=======================

tcsh - 具有文件补全和命令行编辑的 C shell

[概要](#__u6982___u8981_)
=======================

**tcsh \[**\-bcdefFimnqstvVxX**\] \[**\-Dname**\[**\=value**\]\] \[arg ...\]**-
**tcsh -l**

[描述](#__u63CF___u8FF0_)
=======================

_tcsh_ 是 Berkeley UNIX C shell, _csh_(1) 的增强但完全兼容的版本。 它是一种命令语言解释器，可用作交互式登录 shell 和 shell 脚本命令处理器。 它包括一个命令行编辑器（参见 **命令行编辑器**)、可编程单词完成（参见 **完成和列表**)、拼写纠正（参见 **拼写纠正**)、历史机制（参见 **历史替换**)、作业控制（参见 **作业**) 和类似 C 的语法。 **新功能** 部分描述了 _tcsh_ 相对于 _csh_(1) 的主要增强。 在本手册中，大多数 _csh_(1) 实现（特别是 4.4BSD _csh_）中没有的 _tcsh_ 功能都标有 \`(+)', 而 _csh_(1) 中存在但通常没有记录的功能则标有 \`(u)'。

[参数列表处理](#__u53C2___u6570___u5217___u8868___u5904___u7406_)
-----------------------------------------------------------

如果 shell 的第一个参数（参数 0）是 \`-' 那么它是一个登录 shell。 也可以通过使用 **\-l** 标志作为唯一参数调用 shell 来指定登录 shell。

其余标志参数解释如下：

**\-b**

强制从选项处理中“中断”，导致任何进一步的 shell 参数被视为非选项参数。 其余参数不会被解释为 shell 选项。 这可用于将选项传递给 shell 脚本，而不会造成混淆或可能的诡计。 如果没有此选项，shell 将不会运行设置用户 ID 脚本。

**\-c**

命令从以下参数（必须存在，并且必须是单个参数）中读取，存储在 **command** shell 变量中以供参考，然后执行。 任何剩余的参数都放在 **argv** shell 变量中。

**\-d**

shell 从 _~/.cshdirs_ 加载目录堆栈，如 **启动和关闭** 中所述，无论它是否是登录 shell。 (+)

**\-D_name_\[=_value_\]**

将环境变量 _name_ 设置为 _value_. (仅限 Domain/OS) (+)

**\-e**

如果任何调用的命令异常终止或产生非零退出状态，则 shell 退出。

**\-f**

shell 不加载任何资源或启动文件，也不执行任何命令散列，因此启动速度更快。

**\-F**

shell 使用 _fork_(2) 而不是 _vfork_(2) 来生成进程。 (+)

**\-i**

shell 是交互式的，并提示其顶级输入，即使它看起来不是终端。 如果 Shell 的输入和输出是终端，则 Shell 在没有此选项的情况下是交互式的。

**\-l**

该 shell 是一个登录 shell 。仅当 **\-l** 是指定的唯一标志时才适用。

**\-m**

即使它不属于有效用户，shell 也会加载 _~/.tcshrc_ 。 较新版本的 _su_(1) 可以将 **\-m** 传递给 shell。 (+)

**\-n**

shell 解析命令但不执行它们。 这有助于调试 shell 脚本。

**\-q**

shell 接受 SIGQUIT（请参阅 **信号处理**) 并在调试器下使用时表现。 作业控制被禁用。 (u)

**\-s**

命令输入取自标准输入。

**\-t**

shell 读取并执行单行输入。 A \`\\' 可用于在该行末尾转义换行符并继续到另一行。

**\-v**

设置 **verbose** 变量，以便在历史替换后回显命令输入。

**\-x**

设置 **echo** shell 变量，以便在执行前立即回显命令。

**\-V**

甚至在执行 _~/.tcshrc_ 之前设置 **verbose** shell 变量。

**\-X**

与 **\-x** 一样，就像 **\-V** 与 **\-v** 一样。

**\--help**

在标准输出上打印帮助消息并退出。 (+)

**\--version**

在标准输出上打印版本/平台/编译选项并退出。 此信息也包含在 **version** shell 变量中。 (+)

在处理标志参数之后，如果参数仍然存在，但没有给出 **\-c**、 **\-i**、 **\-s** 或 **\-t** 选项，则第一个参数被视为命令文件的名称，或 \`\`script''，被执行。 shell 会打开这个文件并保存它的名字，以便可能用 \`$0' 重新替换。 因为许多系统使用标准版本 6 或版本 7 shell，其 shell 脚本与此 shell 不兼容，所以 shell 使用这种 “标准” shell 来执行第一个字符不是 “#” 的脚本，即不要以评论开头。

剩余的参数放在 **argv** shell 变量中。

[启动和关闭](#__u542F___u52A8___u548C___u5173___u95ED_)
--------------------------------------------------

登录 shell 从执行系统文件 _/etc/csh.cshrc_ 和 _/etc/csh.login_ 中的命令开始。 然后它从用户 **home** 目录中的文件执行命令：首先是 _~/.tcshrc_ (+) ，或者，如果找不到 _~/.tcshrc_ ，则 _~/.cshrc_ ，然后是 _~/.history_ 的内容（或 **histfile** shell 变量）被加载到内存中，然后是 _~/.login_, 最后是 _~/.cshdirs_ （或 **dirsfile** shell 变量的值） (+)。 如果这样编译，shell 可能会在 _/etc/csh.cshrc_ 之前而不是之后读取 _/etc/csh.login_ ，并且在 _~/.tcshrc_ 或 _~/.cshrc_ 和 _~/.history_ 之前而不是之后读取 _~/.login_ ；查看 **version** 变量。 (+)

非登录 shell 在启动时只读 _/etc/csh.cshrc_ 和 _~/.tcshrc_ 或 _~/.cshrc_ 。

启动文件示例请参考 _http://tcshrc.sourceforge.net_。

像 _stty_(1) 和 _tset_(1) 这样的命令，每次登录只需要运行一次，通常放在一个人的 _~/.login_ 文件中。 需要在 _csh_(1) 和 _tcsh_ 中使用同一组文件的用户只能拥有一个 _~/.cshrc_ ，它在使用 _tcsh_ 特定命令之前检查 **tcsh** shell 变量 (qv) 的存在，或者两者都拥有一个 _~/.cshrc_ 和 _~/.tcshrc_ 哪个 _source_ （参见内置命令） _~/.cshrc_ 。 本手册的其余部分使用 \`_~/.tcshrc_ 来表示 \`_~/.tcshrc_ ，或者，如果找不到 _~/.tcshrc_ ，则使用 _~/.cshrc_'。

在正常情况下，shell 开始从终端读取命令，并以 \`> ' 提示。 （参数的处理和使用 shell 处理包含命令脚本的文件将在后面描述。） shell 反复读取一行命令输入，将其分解为单词，将其放在命令历史列表中，对其进行解析并执行该行中的每个命令。

可以通过在空行输入 \`^D'、\`logout' 或 \`login' 或通过 shell 的自动注销机制（参见 **autologout** shell 变量）来注销。 当登录 shell 终止时，它会根据需要将 **logout** shell 变量设置为 \`normal' 或 \`automatic' ，然后从文件 _/etc/csh.logout_ 和 _~/.logout_ 执行命令。 如果这样编译，shell 可能会在注销时丢弃 DTR；查看 **version** shell 变量。

系统登录和注销文件的名称因系统而异，以便与不同的 _csh_(1) 变体兼容；见 **文件**。

[编辑](#__u7F16___u8F91_)
-----------------------

我们首先描述 **命令行编辑器**。 **完成和列表** 以及 **拼写更正** 部分描述了两组功能，它们作为编辑器命令实现，但值得单独处理。 最后， **编辑器命令** 列出并描述了特定于 shell 的编辑器命令及其默认绑定。

[命令行编辑器 (+)](#__u547D___u4EE4___u884C___u7F16___u8F91___u5668__(+))
-------------------------------------------------------------------

可以使用与 _emacs_(1) 和 _vi_(1) 中使用的键序列非常相似的键序列来编辑命令行输入。 仅当设置了编辑 shell 变量时，编辑器才处于活动状态，默认情况下，它在交互式 shell 中处于活动状态。 内置的 _bindkey_ 以显示和更改键绑定。 默认情况下使用 _emacs_(1) 样式的键绑定（除非另外编译了 shell；请参阅 **version** 变量），但 _bindkey_ 可以将键绑定更改为 _vi_(1) 样式的绑定。

shell 总是将箭头键（在 **TERMCAP** 环境变量中定义）绑定到

down

_down-history_

up

_up-history_

left

_backward-char_

right

_forward-char_

除非这样做会改变另一个单字符绑定。 可以使用 _settc_ 将箭头键转义序列设置为空字符串，以防止这些绑定。 箭头键的 ANSI/VT100 序列始终是绑定的。

其他键绑定在很大程度上是 _emacs_(1) 和 _vi_(1) 用户所期望的，并且可以通过 _bindkey_ 轻松显示，因此无需在此列出。 同样， _bindkey_ 可以列出编辑器命令以及每个命令的简短描述。 某些键绑定具有不同的行为，具体取决于使用的是 _emacs_(1) 还是 _vi_(1) 样式绑定；有关详细信息，请参阅 **vimode** 。

请注意，编辑器命令与 shell 的 “word” 概念不同。 编辑器用不在 shell 变量 **wordchars** 中的任何非字母数字字符分隔单词，而 shell 只识别空格和一些对其具有特殊含义的字符，列在 **词法结构**下。

[完成和补全 (+)](#__u5B8C___u6210___u548C___u8865___u5168__(+))
----------------------------------------------------------

当给定一个独特的缩写时，shell 通常能够完成单词。 键入单词的一部分（例如 \`ls /usr/lost'）并按 Tab 键以运行 _complete-word_ 编辑器命令。 shell 将文件名 \`/usr/lost' 补全为 \`/usr/lost+found/'，用输入缓冲区中的完整单词替换不完整的单词。 （注意终端“/”；完成在已完成目录的末尾添加一个“/”，在其他已完成单词的末尾添加一个空格，以加快输入速度并提供成功完成的视觉指示。 可以取消设置 **addsuffix** shell 变量来防止这种情况。） 如果没有找到匹配项（也许 \`/usr/lost+found' 不存在），终端铃声响起。 如果单词已经完整（也许你的系统上有一个 \`/usr/lost'，或者你想得太远并且输入了整个内容）一个 \`/' 或空格被添加到末尾，如果它不是' t 已经在那里了。

完成工作在生产线的任何地方，而不仅仅是在最后；完成的文本将行的其余部分向右推。 在单词中间补全通常会导致光标右侧的剩余字符需要删除。

命令和变量可以以几乎相同的方式完成。 例如，如果 _emacs_ 是系统上唯一以 \`em' 开头的命令，则键入 \`em\[tab\]' 将完成 \`em' 到 \`emacs'。 完成可以在 **path** 中的任何目录中找到命令，或者如果给定完整的路径名。 如果没有其他变量以 \`ar' 开头，键入 \`echo $ar\[tab\]' 将完成 \`$ar' 到 \`$argv'。

shell 解析输入缓冲区以确定您要完成的单词是否应该作为文件名、命令或变量完成。 缓冲区中的第一个单词和 \`;'、\`|'、\`|&'、\`&&' 或 \`||' 之后的第一个单词 被认为是一个命令。 以“$”开头的单词被认为是一个变量。 其他任何东西都是文件名。 空行作为文件名“完成”。

您可以随时通过键入 “^D” 来运行 _delete-char-or-list-or-eof_ 编辑器命令来列出单词的可能完成。 shell 使用 _ls-F_ 内置命令 (qv) 列出可能的完成，并重新打印提示符和未完成的命令行，例如：

\> ls /usr/l\[^D\]-
lbin/ lib/ local/ lost+found/-
\> ls /usr/l

如果设置了 **autolist** shell 变量，那么只要完成失败，shell 就会列出剩余的选项（如果有的话）：

\> set autolist-
\> nm /usr/lib/libt\[tab\]-
libtermcap.a@ libtermlib.a@-
\> nm /usr/lib/libterm

如果 **autolist** 设置为 \`ambiguous'，则仅在完成失败时才会列出选项，并且不会向正在完成的单词添加新字符。

要完成的文件名可以包含变量、您自己或他人的主目录，缩写为 “~” （参见 **文件名替换**) 和目录堆栈条目，缩写为 “=” （参见 **目录堆栈替换**)。 例如，

\> ls ~k\[^D\]-
kahn kas kellogg-
\> ls ~ke\[tab\]-
\> ls ~kellogg/

或

\> set local = /usr/local-
\> ls $lo\[tab\]-
\> ls $local/\[^D\]-
bin/ etc/ lib/ man/ src/-
\> ls $local/

请注意，变量也可以使用 _expand-variables_ 编辑器命令显式扩展。

_delete-char-or-list-or-eof_ 仅在行尾列出；在一行的中间，它删除光标下的字符，并在空行上记录一个字符，或者，如果设置了 **ignoreeof** ，则什么也不做。 \`M-^D'，绑定到编辑器命令 _list-choices_, 列出一行中任何地方的完成可能性，以及 _list-choices_ (或任何一个相关的编辑器命令，可以删除、列出和/或记录 out, 在 _delete-char-or-list-or-eof_ 下列出) 如果需要，可以使用 _bindkey_ 内置命令绑定到 \`^D'。

_complete-word-fwd_ 和 _complete-word-back_ 编辑器命令（默认情况下不绑定到任何键）可用于在可能的补全列表中上下循环，用下一个或上一个单词替换当前单词列表。

shell 变量 **fignore** 可以设置为完成时忽略的后缀列表。 考虑以下：

\> ls-
Makefile condiments.h~ main.o side.c-
README main.c meal side.o-
condiments.h main.c~-
\> set fignore = (.o \\~)-
\> emacs ma\[^D\]-
main.c main.c~ main.o-
\> emacs ma\[tab\]-
\> emacs main.c

\`main.c~' 和 \`main.o' 被补全忽略（但不列出），因为它们以 **fignore** 的后缀结尾。 请注意，在 \`~' 前面需要一个 \`\\' 以防止它被扩展为 **home** ，如 **文件名替换** 中所述。 如果只有一个完成是可能的，则忽略 **fignore** 。

如果 **complete** 变量设置为 \`enhance'，则完成 1) 忽略大小写和 2) 将句点、连字符和下划线（\`.'、 \`-' 和 \`\_'）视为单词分隔符，并且连字符和下划线等效. 如果您有以下文件

comp.lang.c comp.lang.perl comp.std.c++-
comp.lang.c++ comp.std.c

并输入 \`mail -f c.l.c\[tab\]', 它会补全为 \`mail -f comp.lang.c', 而 ^D 会列出 \`comp.lang.c' 和 \`comp.lang.c++'。 \`mail -f c..c++\[^D\]' 将列出 \`comp.lang.c++' 和 \`comp.std.c++' 。在以下目录中键入 \`rm a--file\[^D\]'

A\_silly\_file a-hyphenated-file another\_silly\_file

将列出所有三个文件，因为忽略大小写并且连字符和下划线是等效的。 但是，句点不等同于连字符或下划线。

如果 **complete** shell 变量设置为 \`Enhance'，则仅当用户键入小写字符或连字符时，完成才会忽略大小写以及连字符和下划线分隔符之间的差异。 输入大写字符或下划线将不匹配相应的小写字符或连字符分隔符。 在上一个示例的目录中输入 \`rm a--file\[^D\]' 仍然会列出所有三个文件，但输入 \`rm A--file' 将仅匹配 \`A\_silly\_file' 并输入 \`rm a\_\_file\[^D\]' 将只匹配 \`A\_silly\_file' 和 \`another\_silly\_file' 因为用户明确使用了大写或下划线字符。

完成和列出受其他几个 shell 变量的影响： **recexact** 可以设置为在最短的唯一匹配上完成，即使更多的输入可能会导致更长的匹配：

\> ls-
fodder foo food foonly-
\> set recexact-
\> rm fo\[tab\]

只是哔哔声，因为 \`fo' 可以扩展为 \`fod' 或 \`foo'，但如果我们输入另一个 \`o'，

\> rm foo\[tab\]-
\> rm foo

完成在 \`foo' 上完成，即使 \`food' 和 \`foonly' 也匹配。 **autoexpand** 可以设置为在每次完成尝试之前运行 _expand-history_ 编辑器命令， **autocorrect** 可以设置为在每次完成尝试之前对要完成的单词进行拼写更正（请参阅 **拼写更正**) ，而 **correct** 可以设置为在一个之后自动完成命令点击“返回”。 **matchbeep** 可以设置在各种情况下发出完成蜂鸣声或不发出蜂鸣声， **nobeep** 可以设置为从不发出蜂鸣声。 **nostat** 可以设置为与目录匹配的目录和/或模式的列表，以防止完成机制对这些目录进行 _stat_(2) 处理。 **listmax** 和 **listmaxrows** 可以设置为限制在不先询问的情况下列出的项目和行的数量（分别）。可以设置 **recognize\_only\_executables** 使 shell 在列出命令时只列出可执行文件，但是速度很慢。

最后， _complete_ 的内置命令可用于告诉 shell 如何完成文件名、命令和变量以外的单词。 补全和列出不适用于 glob-patterns（请参阅 **文件名替换**) ，但 _list-glob_ 和 _expand-glob_ 编辑器命令对 glob-patterns 执行等效功能。

[拼写更正 (+)](#__u62FC___u5199___u66F4___u6B63__(+))
-------------------------------------------------

shell 有时可以更正文件名、命令和变量名的拼写，以及完成和列出它们。

可以使用 _spell-word_ 编辑器命令（通常绑定到 Ms 和 MS）和使用 _spell-line_ （通常绑定到 M-$）对整个输入缓冲区进行拼写更正。 **correct** shell 变量可以设置为 \`cmd' 以更正命令名称或 \`all' 以在每次键入 return 时更正整行，并且可以设置 **autocorrect** 以在每次完成尝试之前更正要完成的单词。

当以任何这些方式调用拼写更正并且 shell 认为命令行的任何部分拼写错误时，它会使用更正的行进行提示：

\> set correct = cmd-
\> lz /usr/bin-
CORRECT>ls /usr/bin (y|n|e|a)?

可以回答 “y” 或空格来执行更正的行，“e” 可以将未更正的命令留在输入缓冲区中，“a” 可以中止命令，就好像 “^C” 被击中一样，以及其他任何东西来执行原线不变。

拼写更正可识别用户定义的补全（请参阅 _complete_ 内置命令）。 如果定义补全位置的输入单词与补全列表中的单词相似，则拼写更正会记录拼写错误并建议后一个单词作为更正。 但是，如果输入单词与该位置的任何可能完成不匹配，则拼写更正不会记录拼写错误。

与补全一样，拼写更正可以在行中的任何位置进行，将行的其余部分向右推，并可能在光标右侧留下额外的字符。

[编辑器命令 (+)](#__u7F16___u8F91___u5668___u547D___u4EE4__(+))
----------------------------------------------------------

\`bindkey' 列出键绑定和 \`bindkey -l' 列表并简要描述编辑器命令。 这里只描述新的或特别有趣的编辑器命令。 有关每个编辑器的键绑定的描述，请参见 _emacs_(1) 和 _vi_(1) 。

每个命令默认绑定的一个或多个字符在括号中给出。 \`^_character_' 表示控制字符，而 \`M-_character_ 表示元字符，在没有元键的终端上键入为转义 _character_ 。 大小写计数，但默认情况下绑定到字母的命令为方便起见绑定到小写和大写字母。

**backward-char (^B, left)**

向后移动一个字符。 **vimode** 修改的光标行为。

**backward-delete-word (M-^H, M-^?)**

从当前单词的开头剪切到光标 - 保存在剪切缓冲区中。 **vimode** 修改的字边界行为。

**backward-word (M-b, M-B)**

移动到当前单词的开头。 **vimode** 修改的字边界和光标行为。

**beginning-of-line (^A, home)**

移动到行首。 **vimode** 修改的光标行为。

**capitalize-word (M-c, M-C)**

大写从光标到当前单词结尾的字符。 **vimode** 修改的字边界行为。

**complete-word (tab)**

按照 **完成和列表** 中的描述完成一个单词。

**complete-word-back (not bound)**

与 _complete-word-fwd_ 类似，但从列表末尾开始。

**complete-word-fwd (not bound)**

用可能完成列表中的第一个单词替换当前单词。 可能会重复通过列表逐步降级。 在列表末尾，发出哔哔声并恢复为不完整的单词。

**complete-word-raw (^X-tab)**

与 _complete-word_ 类似，但忽略用户定义的补全。

**copy-prev-word (M-^\_)**

将当前行中的前一个单词复制到输入缓冲区中。 另见 _insert-last-word_ 。 **vimode** 修改的字边界行为。

**dabbrev-expand (M-/)**

将当前单词扩展为当前是前导子字符串的最近的前一个单词，必要时环绕历史列表（一次）。 重复 _dabbrev-expand_ 而没有对下一个前一个单词等进行任何干预的键入更改，跳过相同的匹配项，就像 _history-search-backward_ 所做的那样。

**delete-char (not bound)**

删除光标下的字符。另请参阅 _delete-char-or-list-or-eof_ 。 **vimode** 修改的光标行为。

**delete-char-or-eof (not bound)**

如果光标下有字符或空行上有 _end-of-file_ ，则执行 _delete-char_ 。 另请参阅 _delete-char-or-list-or-eof_ 。 **vimode** 修改的光标行为。

**delete-char-or-list (not bound)**

如果光标下有一个字符，或者行尾有 _list-choices_ ，则执行 _delete-char_ 。 另请参阅 _delete-char-or-list-or-eof_ 。

**delete-char-or-list-or-eof (^D)**

如果光标下有一个字符，则执行 _delete-char_ ，行尾的 _list-choices_ 或在空行的 _end-of-file_ 。 另请参见这三个命令，每个命令只执行一个操作，以及 _delete-char-or-eof_、 _delete-char-or-list_ 和 _list-or-eof_, 每个命令执行三个中不同的两个。

**delete-word (M-d, M-D)**

从光标剪切到当前单词的结尾 - 保存在剪切缓冲区中。**vimode** 修改的字边界行为。

**down-history (down-arrow, ^N)**

像 _up-history_, 但步下，停在原来的输入行。

**downcase-word (M-l, M-L)**

小写从光标到当前单词结尾的字符。 **vimode** 修改的字边界行为。

**end-of-file (not bound)**

发出文件结束信号，导致 shell 退出，除非设置了 **ignoreeof** shell 变量 (qv) 来防止这种情况。 另请参阅 _delete-char-or-list-or-eof_ 。

**end-of-line (^E, end)**

将光标移动到行尾。 **vimode** 修改的光标行为。

**expand-history (M-space)**

扩展当前单词中的历史替换。请参阅 **历史替换** 。 另请参见 _magic-space_、 _toggle-literal-history_ 和 **autoexpand** shell 变量。

**expand-glob (^X-\*)**

将全局模式扩展到光标左侧。请参阅 **文件名替换** 。

**expand-line (not bound)**

与 _expand-history_ 类似，但扩展了输入缓冲区中每个单词的历史替换。

**expand-variables (^X-$)**

将变量展开到光标左侧。 请参阅 **变量替换** 。

**forward-char (^F, right)**

向前移动一个字符。 **vimode** 修改的光标行为。

**forward-word (M-f, M-F)**

前进到当前单词的结尾。 **vimode** 修改的字边界和光标行为。

**history-search-backward (M-p, M-P)**

在历史列表中向后搜索从输入缓冲区的当前内容开始直到光标的命令，并将其复制到输入缓冲区中。 搜索字符串可以是包含 “\*”、“?”、“\[\]” 或 “{}” 的全局模式（参见 **文件名替换**) 。 _up-history_ 和 _down-history_ 将从历史列表中的适当点开始。 仅限 Emacs 模式。 另请参阅 _历史向前搜索_ and _i-search-back_ 。

**history-search-forward (M-n, M-N)**

与 _history-search-backward_ 类似，但向前搜索。

**i-search-back (not bound)**

像 _history-search-backward_ 一样向后搜索，将第一个匹配复制到输入缓冲区中，光标位于模式的末尾，并使用 \`bck:' 和第一个匹配进行提示。 可以键入其他字符来扩展搜索，可以键入 _i-search-back_ 以继续使用相同的模式进行搜索，必要时环绕历史列表， (_i-search-back_ 必须绑定到单个字符才能工作）或可以键入以下特殊字符之一：

^W

将光标下单词的其余部分附加到搜索模式。

删除（或任何绑定到 _backward-delete-char_)

撤消最后输入的字符的效果，并在适当的情况下从搜索模式中删除一个字符。

^G

如果先前的搜索成功，则中止整个搜索。 如果没有，则返回上一次成功的搜索。

escape

结束搜索，将当前行留在输入缓冲区中。

任何其他未绑定到 _self-insert-command_ 的字符都会终止搜索，将当前行留在输入缓冲区中，然后被解释为正常输入。 特别是，回车会导致当前行被执行。 另请参阅 _i-search-fwd_ 和 _history-search-backward_ 。 **vimode** 修改的字边界行为。

**i-search-fwd (not bound)**

与 _i-search-back_ 类似，但向前搜索。 **vimode** 修改的字边界行为。

**insert-last-word (M-\_)**

将前一个输入行的最后一个单词 (\`!$') 插入输入缓冲区。 另请参阅 _copy-prev-word_ 。

**list-choices (M-^D)**

列出 **Completion and listing** 下所述的完成可能性。 另请参阅 _delete-char-or-list-or-eof_ 和 _list-choices-raw_ 。

**list-choices-raw (^X-^D)**

与 _list-choices_ 类似，但忽略用户定义的补全。

**list-glob (^X-g, ^X-G)**

列表（通过 _ls-F_ 内置) 与光标左侧的全局模式（请参阅 **文件名替换**) 匹配。

**list-or-eof (not bound)**

在空行上执行 _list-choices_ 或 _end-of-file_ 。 另请参阅 _delete-char-or-list-or-eof_ 。

**magic-space (not bound)**

扩展当前行中的历史替换，如 _expand-history_ ，并插入一个空格。 _magic-space_ 设计为与空格键绑定，但默认不绑定。

**normalize-command (^X-?)**

在 PATH 中搜索当前单词，如果找到，则将其替换为可执行文件的完整路径。 特殊字符被引用。 别名被扩展和引用，但别名中的命令不是。 该命令对于将命令作为参数的命令很有用，例如 \`dbx' 和 \`sh -x'。

**normalize-path (^X-n, ^X-N)**

按照 **symlinks** shell 变量的 \`expand' 设置中的描述扩展当前单词。

**overwrite-mode (unbound)**

在输入和覆盖模式之间切换。

**run-fg-editor (M-^Z)**

保存当前输入行并在 **editors** shell 变量中找到第一个单词的文件名部分的已停止作业。 如果没有设置 **editors** ，那么将使用 **EDITOR** 环境变量的文件名部分（如果未设置，则为 “ed”）和 **VISUAL** 环境变量（如果未设置，则为 “vi”）。 如果找到这样的作业，它会重新启动，就好像输入了 \`fg %_job_' 一样。 这用于轻松地在编辑器和外壳之间来回切换。 有些人将此命令绑定到 \`^Z'，以便他们可以更轻松地执行此操作。

**run-help (M-h, M-H)**

搜索有关当前命令的文档，使用与完成例程相同的“当前命令”概念，并打印它。 没有办法使用寻呼机； _run-help_ 专为简短的帮助文件而设计。 如果定义了特殊别名 **helpcommand** ，它将以命令名作为唯一参数运行。 否则，文档应位于名为 _command_.help、 _command_.1、 _command_.6、 _command_.8 或 _command_ 的文件中，该文件应位于 **HPATH** 环境变量中列出的目录之一中。 如果有多个帮助文件，则只打印第一个。

**self-insert-command (text characters)**

在插入模式（默认）下，将键入的字符插入到光标下字符之后的输入行中。 在覆盖模式下，用键入的字符替换光标下的字符。 输入模式通常保留在行之间，但 **inputmode** shell 变量可以设置为 “insert” 或 “overwrite” 以将编辑器置于每行开头的该模式。 另请参见 _覆盖模式_ 。

**sequence-lead-in (arrow prefix, meta prefix, ^X)**

表示以下字符是多键序列的一部分。 将一个命令绑定到一个多键序列实际上会创建两个绑定：第一个字符到 _sequence-lead-in_ 和整个序列到命令。 所有以绑定到 _sequence-lead-in_ 的字符开头的序列都有效地绑定到 _undefined-key_ ，除非绑定到另一个命令。

**spell-line (M-$)**

尝试更正输入缓冲区中每个单词的拼写，例如 _spell-word_ ，但忽略第一个字符是 “-”、“！”、“^” 或 “%” 或包含 “\\” 的单词， \`\*' 或 \`?'，以避免开关、替换等问题。 请参阅 **拼写更正**。

**spell-word (M-s, M-S)**

尝试按照 **拼写更正** 中的说明更正当前单词的拼写。 检查似乎是路径名的单词的每个组成部分。

**toggle-literal-history (M-r, M-R)**

扩展或“取消扩展”输入缓冲区中的历史替换。 另请参阅 _expand-history_ 和 **autoexpand** 变量。

**undefined-key (any unbound key)**

哔哔声。

**up-history (up-arrow, ^P)**

将历史列表中的前一个条目复制到输入缓冲区中。 如果设置了 **histlit** ，则使用条目的文字形式。 可能会重复通过历史列表逐步向上，在顶部停止。

**upcase-word (M-u, M-U)**

从光标到当前单词结尾的字符大写。 **vimode** 修改的字边界行为。

**vi-beginning-of-next-word (not bound)**

转到下一个单词的开头。 **vimode** 修改的字边界和光标行为。

**vi-eword (not bound)**

Vi 移动到当前单词的末尾。 **vimode** 修改的字边界行为。

**vi-search-back (?)**

用“？”提示 对于搜索字符串（可能是全局模式，与 _history-search-backward_ 一样），搜索它并将其复制到输入缓冲区中。 如果没有找到匹配项，铃声就会响起。 点击 return 结束搜索并将最后一个匹配项留在输入缓冲区中。 点击转义结束搜索并执行匹配。 仅限 _vi_ 模式。

**vi-search-fwd (/)**

类似于 _vi-search-back_ ，但向前搜索。

**which-command (M-?)**

对输入缓冲区的第一个字执行 _which_ 参见内置命令的描述）。

**yank-pop (M-y)**

在 _yank_ 或另一个 _yank-pop_ 之后立即执行时，将 yank 字符串替换为 killring 中的下一个前一个字符串。 这也有旋转 killring 的效果，这样这个字符串将被认为是最近被后面的 _yank_ 命令杀死的。 重复 _yank-pop_ 将在 killring 中循环任意次数。

[词汇结构](#__u8BCD___u6C47___u7ED3___u6784_)
-----------------------------------------

shell 将输入行拆分为空格和制表符处的单词。 特殊字符 \`&'、\`|'、\`;'、\`<'、\`>'、\`(' 和 \`)' 和双字符 \`&&'、\`||'、\`<<' 和 \` >>' 始终是单独的单词，无论它们是否被空格包围。

当 shell 的输入不是终端时，使用字符 \`#' 开始注释。 每个 \`#' 和它出现的输入行的其余部分在进一步解析之前被丢弃。

特殊字符（包括空格或制表符）可能会被阻止具有其特殊含义，并且可能会成为另一个单词的一部分，方法是在它前面加上反斜杠（\`\\'）或将其括在单（'''），双 (\`"' ) 或后向 (\`\`') 引号。 如果没有以其他方式引用，则以 \`\\' 开头的换行符等效于空白，但在引号内，此序列会产生换行符。

此外，除了 **History substitution** 之外的 **Substitutions** （见下文）都可以通过用单引号括住它们出现的字符串（或字符串的一部分）或通过引用关键字符（例如，\`$' 或 \`\`' 分别用于 **Variable substitution** 或 **Command substitution** ）与 \`\\'。 (**Alias substitution** 也不例外：以任何方式引用已定义 _alias_ 的单词的任何字符都可以防止替换别名。 引用别名的常用方法是在其前面加上反斜杠。)反斜杠可以防止 **History substitution** ，但单引号不能。 用双引号或反引号引用的字符串会进行 **Variable substitution** 和 **Command substitution** ，但会阻止其他替换。

单引号或双引号内的文本变成一个单词（或一个单词的一部分）。 这些字符串中的元字符（包括空格和制表符）不会形成单独的单词。 只有在一种特殊情况下（参见下面的 **Command substitution** ），双引号字符串可以产生多个单词的部分；单引号字符串永远不会。 后向引号很特殊：它们表示 **Command substitution** (qv)，这可能导致多个单词。

引用复杂的字符串，尤其是本身包含引用字符的字符串，可能会造成混淆。 请记住，不必像在人类写作中那样使用引号！可能更容易引用不是整个字符串，而是仅引用字符串中需要引用的那些部分，如果合适的话，使用不同类型的引用来这样做。

可以设置 **backslash\_quote** shell 变量 (qv) 以使反斜杠始终引用 \`\\'、 \`'' 和 \`"' 。 (+) 这可能会使复杂的引用任务变得更容易，但它可能会导致 _csh_(1) 脚本中的语法错误。

[替换](#__u66FF___u6362_)
-----------------------

我们现在描述 shell 按照它们发生的顺序对输入执行的各种转换。 我们在传递所涉及的数据结构以及影响它们的命令和变量时会注意到。 请记住，可以通过在 **词法结构**。

[历史替代](#__u5386___u53F2___u66FF___u4EE3_)
-----------------------------------------

从终端输入的每个命令或“事件”都保存在历史列表中。 前面的命令总是被保存， **history** shell 变量可以设置为一个数字来保存那么多的命令。 **histdup** shell 变量可以设置为不保存重复事件或连续重复事件。

保存的命令从 1 开始按顺序编号，并带有时间标记。 通常不需要使用事件编号，但当前事件编号可以通过放置 “！” 作为提示的一部分。在 **prompt** shell 变量中。

shell 实际上以扩展和文字（未扩展）的形式保存历史。 如果设置了 **histlit** shell 变量，则显示和存储历史记录的命令使用文字形式。

_history_ 内置命令可以随时打印、存储在文件中、恢复和清除历史列表，并且可以设置 **savehist** 和 **histfile** shell 变量在注销时自动存储历史列表并在登录时恢复。

历史替换将历史列表中的单词引入到输入流中，从而可以轻松地重复命令、在当前命令中重复上一个命令的参数或修复上一个命令中的拼写错误，而且输入很少且置信度很高。

历史替换以字符“！”开头。它们可以从输入流中的任何位置开始，但它们不会嵌套。 这个特殊的缩写将在后面描述。 可以通过设置 histchars shell 变量来更改用于表示历史替换的字符（\`!' 和 \`^'）。 任何包含历史替换的输入行在执行之前都会被打印出来。

历史替换可能有一个 “event specification”，它指示要从中提取词的事件，一个 “word designator”，它从选定的事件中选择特定的词，和/或一个 “modifier” ，它操纵选定的单词。

事件规范可以是

_n_

一个数字，指的是一个特定的事件

\-_n_

一个偏移量，指的是当前事件之前的事件 _n_

#

当前事件。 这应该在不检查递归的 _csh_(1) 中谨慎使用。 _tcsh_ 允许 10 级递归。 (+)

!

上一个事件（相当于 \`-1')

_s_

第一个单词以字符串 _s_ 开头的最近事件

?_s_?

包含字符串 _s_ 的最新事件。 第二个“？” 如果后面紧跟换行符，则可以省略。

例如，考虑一下某人的历史列表：

 9 8:30 nroff -man wumpus.man-
10 8:31 cp wumpus.man wumpus.man.old-
11 8:36 vi wumpus.man-
12 8:37 diff wumpus.man.old wumpus.man

这些命令连同它们的事件编号和时间戳一起显示。 我们尚未输入的当前事件是事件 13。 \`!!' 指上一个事件，12。 \`!!' 可以缩写为 \`!' 如果它后面跟着 \`:' (\`:' 将在下面描述）。 \`!n' 指的是事件 9，它以 \`n' 开头。 \`!?old?' 也指事件 12，其中包含 \`old' 。 如果没有单词指示符或修饰符，历史引用只会扩展到整个事件，因此我们可以输入 \`!cp' 来重做复制命令，或者如果 \`diff' 输出滚动到屏幕顶部，我们可能会输入 \`!!|more' 。

历史参考可以在必要时用大括号与周围的文本隔离开来。例如， \`!vdoc' 会查找以 \`vdoc' 开头的命令，并且在本例中找不到，但 \`!{v}doc' 会明确地扩展为 \`vi wumpus.mandoc'。 即使在大括号中，历史替换也不会嵌套。

(+) 例如，当 _csh_(1) 将 \`!3d' 扩展为事件 3 并附加了字母 \`d' 时， _tcsh_ 将其扩展为以 \`3d' 开头的最后一个事件；只有完全数字的参数被视为事件编号。 这使得调用以数字开头的事件成为可能。 要在 _csh_(1) 中扩展 \`!3d' ，请说 \`!{3}d'。

要从事件中选择单词，我们可以按照事件规范使用 \`:' 和所需单词的指示符。 输入行的单词从 0 开始编号，第一个（通常是命令）单词为 0，第二个单词（第一个参数）为 1，以此类推。 基本的词指示符是：

0

第一个（命令）词

_n_

第 _n_ 个参数

^

第一个参数，相当于 \`1'

$

最后的论据

%

用 ?_s_? 搜索匹配的词

_x-y_

一系列单词

_\-y_

相当于 _\`0-y'_

\*

相当于 \`^-$' ，但如果事件仅包含 1 个单词，则不返回任何内容

_x\*_

相当于 _\`x-$'_

_x-_

相当于 _\`x\*'_ ，但省略了最后一个单词 (\`$')

选定的单词被插入到由单个空格分隔的命令行中。 例如，前面例子中的 \`diff' 命令可能被输入为 \`diff !!:1.old !!:1' (使用 \`:1' 选择前一个事件的第一个参数）或 \`diff !-2:2 !-2:1' 从 \`cp' 命令中选择和交换参数。 如果我们不关心 \`diff' 的顺序，我们可能会说 \`diff !-2:1-2' 或简单地说 \`diff !-2:\*'。 \`cp' 命令可能写成 \`cp wumpus.man !#:1.old', 使用 \`#' 表示当前事件。 \`!n:- hurkle.man' 将重用来自 \`nroff' 命令的前两个单词来表示 \`nroff -man hurkle.man'。

如果参数选择器以 \`^', \`$', \`\*', \`%' 或 \`-' 开头，则可以省略分隔事件规范和单词指示符的 \`:' 。 例如，我们的 \`diff' 命令可能是 \`diff !!^.old !!^' 或等价的 \`diff !!$.old !!$' 。 但是，如果 \`!!' 缩写为 \`!', 以 \`-' 开头的参数选择器将被解释为事件规范。

历史参考可能有一个词指示符，但没有事件规范。 然后它引用前面的命令。 继续我们的 \`diff' 示例，我们可以简单地说 \`diff !^.old !^' 或者，以相反的顺序获得参数，只是 \`diff !\*'。

历史引用中的一个或多个单词可以被编辑或 \`\`modified''，方法是在它后面加上一个或多个修饰符，每个修饰符前面都有一个 \`:':

h

删除尾随路径名组件，留下头部。

t

删除所有前导路径名组件，留下尾部。

r

删除文件扩展名 \`.xxx'，保留根名称。

e

删除除扩展名之外的所有内容。

u

大写第一个小写字母。

l

小写第一个大写字母。

s_/l/r/_

用 _l_ 代替 _r_。 _l_ 只是一个类似于 _r_ 字符串，而不是同名的 _ed_(1) 命令中的正则表达式。 任何字符都可以用作分隔符来代替 \`/'; a \`\\' 可用于引用 _l_ 和 _r_ 中的分隔符。 _r_ 中的字符\`&' 被 _l_ 替换； \`\\' 也引用了 \`&'。 如果 _l_ 为空 (\`\`''), 则使用来自先前替换的 _l_ 或来自先前搜索的 _s_ 或事件规范中的事件编号。 如果后面紧跟换行符，则可以省略尾随分隔符。

&

重复前面的替换。

g

对每个单词应用一次以下修饰符。

a (+)

将以下修饰符尽可能多地应用于单个单词。 \`a' 和 \`g' 可以一起使用以全局应用修饰符。 使用 \`s' 修饰符，仅替换原始单词中包含的模式，而不是包含任何替换结果的模式。

p

打印新的命令行但不执行它。

q

引用替换的单词，防止进一步替换。

x

与 q 类似，但在空格、制表符和换行符处分成单词。

修饰符仅适用于第一个可修改的单词（除非使用了 \`g' ）。 没有单词可以修改是错误的。

例如， \`diff' 命令可能写成 \`diff wumpus.man.old !#^:r', 使用 \`:r' 从同一行的第一个参数中删除 \`.old' (\`!#^') 。 我们可以说 \`echo hello out there', 然后说 \`echo !\*:u' 来大写 \`hello', \`echo !\*:au' 来大声说出来，或者 \`echo !\*:agu' 来大喊大叫。 我们可以在 \`mail -s "I forgot my password" rot' 后面加上 \`!:s/rot/root' 来更正 \`root' 的拼写（但请参阅 **拼写更正** 了解不同的方法）。

替换有一个特殊的缩写。 \`^' ，当它是输入行的第一个字符时，等价于 \`!:s^'。 因此，我们可能会说 \`^rot^root' 来进行前面示例中的拼写更正。 这是唯一没有明确以 \`!' 开头的历史替换。

(+) 在这样的 _csh_ 中，只能将一个修饰符应用于每个历史记录或变量扩展。 在 _tcsh_ 中，可以使用多个，例如

% mv wumpus.man /usr/man/man1/wumpus.1-
% man !$:t:r-
man wumpus

在 _csh_ 中，结果将是 \`wumpus.1:r'。 后跟冒号的替换可能需要用大括号与之隔离：

\> mv a.out /usr/games/wumpus-
\> setenv PATH !$:h:$PATH-
Bad ! modifier: $.-
\> setenv PATH !{-2$:h}:$PATH-
setenv PATH /usr/games:/bin:/usr/bin:.

第一次尝试在 _csh_ 中会成功，但在 _tcsh_ 中会失败，因为 _tcsh_ 在第二个冒号之后需要另一个修饰符，而不是 \`$'。

最后，可以通过编辑器以及刚刚描述的替换访问历史记录。 _up-_ 和 _down-history_、 _history-search-backward_ 和 _\-forward_、 _i-search-back_ 和 _\-fwd_、 _vi-search-back_ 和 _\-fwd_、 _copy-prev-word_ 和 _insert-last-word_ 编辑器命令搜索历史列表中的事件并将它们复制到输入缓冲区中。 _toggle-literal-history_ 编辑器命令在输入缓冲区中历史行的展开形式和文字形式之间切换。 _expand-history_ 和 _expand-line_ 分别在当前单词和整个输入缓冲区中展开历史替换。

[别名替换](#__u522B___u540D___u66FF___u6362_)
-----------------------------------------

维护一个别名列表，可以通过 _alias_ 和 _unalias_ 命令设置、取消设置和打印这些别名。 在将命令行解析为简单命令（请参阅 **命令**) 后，检查每个命令的第一个单词，从左到右，看它是否有别名。 如果是这样，则将第一个单词替换为别名。 如果别名包含历史引用，它将经历 **History substitution** (qv)，就好像原始命令是前一个输入行一样。 如果别名不包含历史引用，则参数列表保持不变。

因此，如果 \`ls' 的别名是 \`ls -l' ，那么命令 \`ls /usr' 就会变成 \`ls -l /usr', 这里的参数列表不会受到干扰。 如果 \`lookup' 的别名是 \`grep !^ /etc/passwd' 那么 \`lookup bill' 将变成 \`grep bill /etc/passwd'。 别名可用于引入解析器元语法。 例如， \`alias print 'pr \\!\* | lpr'' 定义了一个 \`\`command'' (\`print') ，它 _pr_(1) 将它的参数传递给行式打印机。

重复别名替换，直到命令的第一个单词没有别名。 如果别名替换没有更改第一个单词（如前面的示例中），则将其标记为防止循环。 检测到其他循环并导致错误。

shell 引用了一些别名；请参阅 **特殊别名**。

[变量替换](#__u53D8___u91CF___u66FF___u6362_)
-----------------------------------------

shell 维护一个变量列表，每个变量都有一个包含零个或多个单词的列表作为值。 可以使用 _set_ 和 _unset_ 命令显示和更改 shell 变量的值。 系统维护自己的 \`\`environment'' 变量列表。 这些可以使用 _printenv_、 _setenv_ 和 _unsetenv_ 显示和更改。

(+) 可以使用 \`set -r'(qv) 将变量设为只读。 只读变量不得修改或取消设置；尝试这样做会导致错误。 一旦设置为只读，就不能将变量设置为可写，因此应谨慎使用 \`set -r' 。 环境变量不能设为只读。

一些变量由 shell 设置或由它引用。例如， **argv** 变量是 shell 参数列表的图像，并且该变量值的单词以特殊方式引用。 shell 引用的一些变量是切换；shell 不关心它们的值是什么，只关心它们是否被设置。 例如， **verbose** 变量是一个切换，它导致命令输入被回显。 **\-v** 命令行选项设置此变量。 **Special shell variables** 列出了 shell 引用的所有变量。

其他操作以数值方式处理变量。 \`@' 命令允许执行数字计算并将结果分配给变量。 但是，变量值始终表示为（零个或多个）字符串。 出于数值运算的目的，空字符串被认为是零，并且忽略多字值的第二个和后续字。

在输入行被别名和解析之后，并且在每个命令被执行之前，变量替换由 \`$' 字符键入。 这种扩展可以通过在 \`$' 前面加上 \`\\' 来防止，除非在 \`"'s 中它 _总是_ 出现，而在 \`'' 中它 _从不_ 出现。 \`\`' 引用的字符串稍后会被解释（见下面的 **命令替换** ），所以 \`$' 替换直到稍后才会发生，如果有的话。 如果后面跟着空格、制表符或换行符，则 \`$' 会被原封不动地传递。

输入/输出重定向在变量扩展之前被识别，并且是单独的变量扩展。 否则，命令名称和整个参数列表将一起展开。 因此，第一个（命令）词（至此）可能生成多个词，其中第一个词成为命令名称，其余词成为参数。

除非包含在 \`"' 中或给定 \`:q' 修饰符，否则变量替换的结果最终可能会被命令和文件名替换。 在 \`"' 中，其值由多个单词组成的变量扩展为单个单词（一部分），变量值的单词由空格分隔。 当\`:q' 修饰符应用于替换时，变量将扩展为多个单词，每个单词由空格分隔并引用以防止以后的命令或文件名替换。

提供以下元序列用于将变量值引入 shell 输入。 除非另有说明，否则引用未设置的变量是错误的。

$_name_

${_name_}

替换变量 _name_ 花括号将 _name_ 与下列字符隔离开来，否则这些字符将成为名称的一部分。Shell 变量的名称由以字母开头的字母和数字组成。 下划线字符被认为是一个字母。 如果 _name_ 不是 shell 变量，而是在环境中设置，则返回该值（但下面给出的其他一些形式在这种情况下不可用）。

$_name_\[_selector_\]

${_name_\[_selector_\]}

仅替换 _name_ 值中的选定单词。 _selector_ 会被 \`$' 替换，并且可以由一个数字或两个数字组成，由一个 \`-' 分隔。 变量值的第一个单词编号为 \`1'。 如果省略范围的第一个数字，则默认为 \`1'。 如果省略范围的最后一个成员，则默认为 \`$#_name_'。 _selector_ \`\*' 选择所有单词。 如果第二个参数被省略或在范围内，则范围为空不是错误。

$0

替换正在从中读取命令输入的文件的名称。 如果名称未知，则会发生错误。

$_number_

${_number_}

相当于 \`$argv\[_number_\]'。

$\*

相当于 \`$argv'，相当于 \`$argv\[\*\]'。

**History substitution** 中描述的 \`:' 修饰符，除了 \`:p', 可以应用于上面的替换。 可以使用不止一个。 (+) 可能需要大括号来将变量替换与文字冒号隔离开来，就像 **History substitution** (qv) 一样；任何修饰符都必须出现在大括号内。

以下替换不能使用 \`:' 修饰符进行修改。

$?_name_

${?_name_}

如果设置了 _name_ ，则替换字符串 \`1' ，如果没有设置，则替换为 \`0' 。

$?0

如果当前输入文件名已知，则替换为 \`1' ，如果不知道，则替换为 \`0' 。 在交互式 shell 中始终为 \`0' 。

$#_name_

${#_name_}

替换 _name_ 中的单词数。

$#

相当于 \`$#argv'。 (+)

$%_name_

${%_name_}

替换 _name_ 中的字符数。 (+)

$%_number_

${%_number_}

替换 $argv\[_number_\] 中的字符数。 (+)

$?

相当于 \`$status'。 (+)

$$

替换（父）shell 的（十进制）进程号。

$!

替换此 shell 启动的最后一个后台进程的（十进制）进程号。 (+)

$\_

替换最后执行的命令的命令行。 (+)

$<

从标准输入中替换一行，此后不再解释。 它可用于在 shell 脚本中从键盘读取。 (+) 虽然 _csh_ 总是引用 $<, 就好像它等同于 \`$<:q',但 _tcsh_ 没有。 此外，当 _tcsh_ 正在等待输入一行时，用户可以输入一个中断来中断要替换该行的顺序，但 _csh_ 不允许这样做。

编辑器命令 _expand-variables_ ，通常绑定到 \`^X-$', 可以用来交互地展开单个变量。

[命令、文件名和目录堆栈替换](#__u547D___u4EE4___u3001___u6587___u4EF6___u540D___u548C___u76EE___u5F55___u5806___u6808___u66FF___u6362_)
--------------------------------------------------------------------------------------------------------------------------

其余的替换选择性地应用于内置命令的参数。 这意味着未计算的表达式部分不受这些扩展的影响。 对于不是 shell 内部的命令，命令名称与参数列表分开替换。 这发生在很晚的时候，在执行输入输出重定向之后，并且在主 shell 的子 shell 中。

[命令替换](#__u547D___u4EE4___u66FF___u6362_)
-----------------------------------------

命令替换由括在 \`\`' 中的命令指示。 此类命令的输出在空格、制表符和换行符处分成单独的单词，并且丢弃空单词。 输出是可变的，并且命令被替换并代替原始字符串。

双引号 (\`"') 内的命令替换保留空格和制表符；只有换行符强制新词。 在任何情况下，单个最终换行符都不会强制使用新单词。 因此，即使命令输出完整的行，命令替换也可能只产生单词的一部分。

默认情况下，6.12 版以来的 shell 将命令中的所有换行符和回车符替换为空格。 如果通过取消设置 **csubstnonl** 将其关闭，则换行符像往常一样分隔命令。

[文件名替换](#__u6587___u4EF6___u540D___u66FF___u6362_)
--------------------------------------------------

如果一个单词包含任何字符 \`\*'、 \`?'、 \`\[' 或 \`{' 或以字符 \`~' 开头，则它是文件名替换的候选对象，也称为 \`\`globbing''。 然后这个词被视为一个模式 (\`\`glob-pattern'') ，并替换为一个按字母排序的与该模式匹配的文件名列表。

在匹配的文件名中，字符 \`.' 在文件名的开头或紧跟在 \`/' 之后，以及字符 \`/' 必须显式匹配（除非 **globdot** 或 **globstar** 或两者都设置 (+)) 。 字符 \`\*' 匹配任何字符串，包括空字符串。 字符 \`?' 匹配任何单个字符。 序列 \`\[...\]' 匹配任何一个包含的字符。 在 \`\[...\]' 中，由 \`-' 分隔的一对字符在词法上匹配两者之间的任何字符。

(+) 一些 glob-patterns 可以被否定：序列 \`\[^...\]' 匹配任何 _未由_ 大括号中的字符和/或字符范围指定的单个字符。

整个 glob 模式也可以用 \`^' 否定：

\> echo \*-
bang crash crunch ouch-
\> echo ^cr\*-
bang ouch

不使用 \`?'、 \`\*' 或 \`\[\]' 或使用 \`{}' 或 \`~' 如下）的全局模式不会被正确否定。

元记法 \`a{b,c,d}e' 是 \`abe ace ade'的简写。 从左到右的顺序被保留： \`/usr/source/s1/{oldls,ls}.c' 扩展为 \`/usr/source/s1/oldls.c /usr/source/s1/ls.c'。 匹配结果在低级别单独排序以保留此顺序： \`../{memo,\*box}' 可能会扩展为 \`../memo ../box ../mbox'。 (注意 \`memo' 没有按照匹配 \`\*box' 的结果排序。) 当此构造扩展到不存在的文件时，这不是错误，但可能会从传递扩展列表的命令中获取错误。 该构造可以嵌套。 作为一种特殊情况，单词 \`{'、 \`}' 和 \`{}' 会不受干扰地传递。

文件名开头的字符 \`~' 指的是主目录。 单独存在，即 \`~', 它会扩展到调用者的主目录，这反映在 **home** shell 变量的值中。 当后面跟着一个由字母、数字和 \`-' 字符组成的名称时，shell 会搜索具有该名称的用户并替换他们的主目录；因此 \`~ken' 可能会扩展为 \`/usr/ken' 而 \`~ken/chmach' 可能会扩展为 \`/usr/ken/chmach'。 如果字符 \`~' 后面跟着一个不是字母或 \`/' 的字符，或者出现在单词开头以外的其他地方，它不会受到干扰。 因此，像 \`setenv MANPATH /usr/man:/usr/local/man:~/lib/man' 这样的命令不会像人们希望的那样进行主目录替换。

包含 \`\*'、 \`?'、 \`\[' 或 \`~'的 glob-pattern 不匹配任何文件都是错误的，无论是否带有 \`^'。 但是， glob-patterns 列表中只有一个模式必须与文件匹配（因此，例如， \`rm \*.a \*.c \*.o' 只有在当前目录中没有以 \`.a'、 \`.c' 或 \`.o')，并且如果设置了 **nonomatch** shell 变量，则不匹配任何内容的模式（或模式列表）保持不变，而不是导致错误。

**globstar** 变量可以设置为允许 \`\*\*' 或 \`\*\*\*' 作为匹配任何字符串（包括 \`/'）的文件 glob 模式，递归遍历任何现有的子目录。 例如， \`ls \*\*.c' 将列出当前目录树中的所有 .c 文件。 如果单独使用，它将匹配零个或多个子目录（例如， \`ls /usr/include/\*\*/time.h' 将列出 /usr/include 目录树中名为 \`time.h' 的任何文件； \`ls /usr/include/\*\*time.h' 将匹配 /usr/include 目录树中以 \`time.h' 结尾的任何文件；并且 \`ls /usr/include/\*\*time\*\*.h' 将匹配任何带有 \`time' 的 .h 文件，无论是在子目录名称中还是在文件名本身中）。 为了防止递归问题， \`\*\*' 全局模式不会下降到包含目录的符号链接。 要覆盖它，请使用 \`\*\*\*' (+)

可以设置 **noglob** shell 变量以防止文件名替换，并且可以使用通常绑定到 \`^X-\*' 的 _expand-glob_ 编辑器命令以交互方式扩展单个文件名替换。

[目录堆栈替换 (+)](#__u76EE___u5F55___u5806___u6808___u66FF___u6362__(+))
-------------------------------------------------------------------

目录堆栈是目录列表，从零开始编号，供 _pushd_、 _popd_ 和 _dirs_ 内置命令 (qv) 使用。 _dirs_ 可以随时打印、存储在文件中、恢复和清除目录堆栈，并且可以设置 **savedirs** 和 **dirsfile** shell 变量在注销时自动存储目录堆栈并在登录时恢复。 可以检查 **dirstack** shell 变量以查看目录堆栈并设置为将任意目录放入目录堆栈。

后跟一个或多个数字的字符 \`=' 扩展为目录堆栈中的一个条目。 特殊情况 \`=-' 扩展到堆栈中的最后一个目录。例如，

\> dirs -v-
0 /usr/bin-
1 /usr/spool/uucp-
2 /usr/accts/sys-
\> echo =1-
/usr/spool/uucp-
\> echo =0/calendar-
/usr/bin/calendar-
\> echo =--
/usr/accts/sys

**noglob** 和 **nonomatch** shell 变量以及 _expand-glob_ 编辑器命令适用于目录堆栈以及文件名替换。

[其他替换 (+)](#__u5176___u4ED6___u66FF___u6362__(+))
-------------------------------------------------

还有几个涉及文件名的转换，与上述不严格相关，但为了完整性在此提及。 当 **symlinks** 变量 (qv) 设置为 \`expand' 时， _Any_ 文件名都可以扩展为完整路径。 引用可以防止这种扩展，而 _normalize-path_ 编辑器命令会按需执行。 _normalize-command_ 编辑器命令根据需要将 PATH 中的命令扩展为完整路径。 最后， _cd_ 和 _pushd_ 将 \`-' 解释为旧的工作目录（相当于 shell 变量 **owd**)。 这根本不是替换，而是只有那些命令才能识别的缩写。 尽管如此，它也可以通过引用来防止。

[命令](#__u547D___u4EE4_)
-----------------------

接下来的三个部分描述了 shell 如何执行命令并处理它们的输入和输出。

[简单命令、管道和序列](#__u7B80___u5355___u547D___u4EE4___u3001___u7BA1___u9053___u548C___u5E8F___u5217_)
-----------------------------------------------------------------------------------------------

一个简单的命令是一个单词序列，其中第一个指定要执行的命令。 一系列由 \`|' 连接的简单命令 字符形成管道。 管道中每个命令的输出都连接到下一个命令的输入。

简单的命令和管道可以用 \`;'连接成序列，并按顺序执行。 命令和管道也可以用 \`||' 加入到序列中 或 \`&&', 与 C 语言一样，表示只有在第一个失败或成功时才执行第二个。

一个简单的命令、管道或序列可以放在括号 \`()' 中，以形成一个简单的命令，该命令又可以是管道或序列的一个组件。 可以执行命令、管道或序列，而无需等待其终止，只需在其后加上 \`&' 即可。

[内置和非内置命令执行](#__u5185___u7F6E___u548C___u975E___u5185___u7F6E___u547D___u4EE4___u6267___u884C_)
-----------------------------------------------------------------------------------------------

内置命令在 shell 中执行。 如果管道的任何组件（最后一个除外）是内置命令，则管道将在子 shell 中执行。

带括号的命令总是在子 shell 中执行。

(cd; pwd); pwd

因此打印 **home** 目录，将您留在原处（在主目录之后打印），而

cd; pwd

留在 **home** 目录中。 带括号的命令最常用于防止 _cd_ 影响当前 shell。

当发现要执行的命令不是内置命令时，shell 会尝试通过 _execve_(2) 执行该命令。 变量 **path** n中的每个单词命名一个目录，shell 将在其中查找命令。 如果没有给 shell 一个 **\-f** 选项，shell 会将这些目录中的名称散列到一个内部表中，以便它只会在命令可能驻留的目录中尝试 _execve_(2) 。 当搜索路径中存在大量目录时，这大大加快了命令定位的速度。 不使用此散列机制：

**1.**

如果散列通过 _unhash_ 显式关闭。

**2.**

如果给 shell 一个 **\-f** 参数。

**3.**

对于不以 \`/' 开头的 **path** 的每个目录组件。

**4.**

如果命令包含 \`/'。

在上述四种情况下，shell 将路径向量的每个组件与给定的命令名连接起来，形成文件的路径名，然后尝试执行该文件。 如果执行成功，则搜索停止。

如果该文件具有执行权限但不是系统可执行文件（即，它既不是可执行二进制文件，也不是指定其解释器的脚本），则假定它是一个包含 shell 命令的文件，并生成一个新的 shell阅读。 _shell_ 特殊别名可以设置为指定一个解释器而不是 shell 本身。

在不理解 \`#!' 的系统上 脚本解释器约定 可以编译 shell 来模拟它；查看 **version** shell 变量。 如果是这样，shell 检查文件的第一行，看它是否是 \`#!_interpreter_ _arg_ ...'的形式。 如果是，shell 使用给定的 _arg_s 启动 _interpreter_ ，并在标准输入上将文件提供给它。

[输入/输出](#__u8F93___u5165_/__u8F93___u51FA_)
-------------------------------------------

可以使用以下语法重定向命令的标准输入和标准输出：

< _name_

打开文件 _name_ （这是第一个变量，命令和文件名扩展）作为标准输入。

<< _word_

将 shell 输入读取到与 _word_ 相同的行。 _word_ 不受变量、文件名或命令替换的影响，并且在对该输入行进行任何替换之前，将每个输入行与 _word_ 进行比较。 除非引用 \`\\'、 \`"'、 \`' 或 \`\`' 出现在 _word_ 变量中并且在中间行执行命令替换，允许 \`\\' 引用 \`$'、 \`\\' 和 \`\`'。 被替换的命令保留了所有空格、制表符和换行符，除了最后一个被删除的换行符。 结果文本被放置在一个匿名临时文件中，该文件作为标准输入提供给命令。

\> _name_-
\>! _name_-
\>& _name_

\>&! _name_

文件 _name_ 用作标准输出。 如果文件不存在，则创建它；如果文件存在，它会被截断，之前的内容会丢失。

如果设置了 shell 变量 **noclobber** ，则该文件不得存在或者是字符特殊文件（例如，终端或 \`/dev/null') 或错误结果。 这有助于防止意外破坏文件。 在这种情况下， \`!' 可以使用表单来禁止此检查。 如果 **noclobber** 中给出了 **notempty** ，则允许在空文件上使用 \`>' ；如果设置了 **ask** ，则会显示交互式确认，而不是错误。

涉及 \`&' 的表单将诊断输出路由到指定文件以及标准输出。 _name_ 的扩展方式与 \`<' 输入文件名的扩展方式相同。

\>> _name_-
\>>& _name_-
\>>! _name_

\>>&! _name_

类似于 \`>'，但将输出附加到 _name_ 的末尾。 如果设置了 shell 变量 **noclobber** ，那么文件 _不_ 存在是错误的，除非其中有一个 \`!' 形式给出了。

命令接收调用 shell 的环境，该环境由输入输出参数和命令在管道中的存在所修改。 因此，与以前的一些 shell 不同，默认情况下，从 shell 命令文件运行的命令无法访问命令文本；而是他们接收 shell 的原始标准输入。 \`<<' 机制应该用于呈现内联数据。 这允许 shell 命令脚本充当管道的组件，并允许 shell 阻止读取其输入。 请注意，分离的命令运行的默认标准输入 _不是_ 空文件 _/dev/null_，而是 shell 的原始标准输入。 如果这是一个终端并且如果进程尝试从终端读取，那么进程将阻塞并且用户将被通知（参见 **作业**)。

诊断输出可以通过具有标准输出的管道引导。 只需使用形式 \`|&' 而不仅仅是 \`|'。

shell 目前无法在不重定向标准输出的情况下重定向诊断输出，但 \`(_command_ > _output-file_) >& _error-file_' 通常是可接受的解决方法。 _output-file_ 或 _error-file_ 可能是 \`/dev/tty' 以将输出发送到终端。

[特征](#__u7279___u5F81_)
-----------------------

在描述了 shell 如何接受、解析和执行命令行之后，我们现在转向它的各种有用的特性。

[控制流](#__u63A7___u5236___u6D41_)
--------------------------------

shell 包含许多命令，可用于调节命令文件（shell 脚本）和（以有限但有用的方式）来自终端输入的控制流。 这些命令都是通过强制 shell 重新读取或跳过其输入来操作的，并且由于实现，限制了某些命令的放置。

_foreach_、 _switch_ 和 _while_ 语句以及 _if_ 语句的 _if-then-else_ 形式要求主要关键字出现在输入行上的单个简单命令中，如下所示。

如果 shell 的输入不可搜索，shell 会在读取循环时缓冲输入，并在此内部缓冲区中执行搜索以完成循环隐含的重读。 （在允许的范围内，反向 _goto_ 将在不可搜索的输入上成功。)

[表达式](#__u8868___u8FBE___u5F0F_)
--------------------------------

_if_ _while_ 和 _exit_ 内置命令使用具有通用语法的表达式。 表达式可以包括接下来三个部分中描述的任何运算符。 请注意， _@_ 内置命令 (qv) 有自己独立的语法。

[逻辑、算术和比较运算符](#__u903B___u8F91___u3001___u7B97___u672F___u548C___u6BD4___u8F83___u8FD0___u7B97___u7B26_)
--------------------------------------------------------------------------------------------------------

这些运算符与 C 中的运算符相似，具有相同的优先级。 它们包括

|| && | ^ & == != =~ !~ <= >=-
< > << >> + - \* / % ! ~ ( )

这里优先级向右增加， \`==' \`!=' \`=~' 和 \`!~', \`<=' \`>=' \`<' 和 \`>', \`<<' 和 \`>>', \`+' 和 \`-', \`\*' \`/' 和 \`%' 在组中处于同一级别。 \`==' \`!=' \`=~' 和 \`!~' 运算符将它们的参数作为字符串进行比较；所有其他人都对数字进行操作。 运算符 \`=~' 和 \`!~' 与 \`!=' 和 \`==' 类似，除了右侧是匹配左侧操作数的全局模式（参见 **文件名替换**) 。 当真正需要的只是模式匹配时，这减少了在 shell 脚本中使用 _switch_ 内置命令的需要。

空参数或缺失参数被视为 \`0'。 所有表达式的结果都是字符串，代表十进制数。 重要的是要注意一个表达式的两个组成部分不能出现在同一个单词中。除非与对解析器具有语法意义的表达式组件相邻 (\`&' \`|' \`<' \`>' \`(' \`)') ，否则它们应该被空格包围。

[命令退出状态](#__u547D___u4EE4___u9000___u51FA___u72B6___u6001_)
-----------------------------------------------------------

命令可以在表达式中执行，并通过将它们括在大括号 (\`{}')中返回它们的退出状态。 请记住，大括号应该用空格与命令的单词分开。 命令执行成功，返回真，即 \`1'，如果命令以状态0退出，否则它们失败，返回假，即 \`0' 。 如果需要更详细的状态信息，则应在表达式之外执行命令并检查 **status** shell 变量。

[文件查询操作员](#__u6587___u4EF6___u67E5___u8BE2___u64CD___u4F5C___u5458_)
--------------------------------------------------------------------

其中一些运算符对文件和相关对象执行真/假测试。 它们的格式为 **\-**_op file_ ，其中 _op_ 是

**r**

读取权限

**w**

写访问

**x**

执行访问

**X**

可在路径或内置 shell 中执行，例如 \`-X ls' 和 \`-X ls-F' 通常为真，但 \`-X /bin/ls' 不是 (+)

**e**

存在

**o**

所有权

**z**

零尺寸

**s**

非零大小 (+)

**f**

普通文件

**d**

目录

**l**

符号链接 (+) \*

**b**

阻止特殊文件 (+)

**c**

字符特殊文件 (+)

**p**

命名管道 (fifo) (+) \*

**S**

套接字特殊文件 (+) \*

**u**

设置用户 ID 位 (+)

**g**

设置组 ID 位已设置 (+)

**k**

粘滞位已设置 (+)

**t**

_file_ （必须是数字）是终端设备的打开文件描述符 (+)

**R**

已迁移 (仅 Convex) (+)

**L**

将多运算符测试中的后续运算符应用于符号链接，而不是链接指向的文件 (+) \*

_file_ 是命令和文件名扩展，然后测试它是否与真实用户具有指定的关系。如果 _file_ 不存在或不可访问，或者对于 \`\*' 表示的运算符，如果指定的文件类型在当前系统中不存在，则所有查询返回false，即 \`0'。

为简洁起见，这些运算符可以组合使用： \`-_xy file_' 等价于 \`-_x file_ && -_y file_'。 (+) 例如，对于普通的可执行文件， \`-fx' 为真（返回 \`1') ，但不适用于目录。

**L** 可用于多运算符测试，以将后续运算符应用于符号链接，而不是链接指向的文件。 例如， \`-lLo' 对于调用用户拥有的链接是正确的。 **Lr**、 **Lw** 和 **Lx** 对于链接始终为真，对于非链接始终为假。 当 **L** 是多算子测试中的最后一个算子时，其含义不同；见下文。

将期望 _file_ 是文件的运算符与不是文件的运算符（例如， **X** 和 **t**)结合起来是可能的，但不是有用的，而且有时会产生误导。 在 **L** 后面加上一个非文件运算符会导致特别奇怪的结果。

其他运算符返回其他信息，即，不仅仅是 \`0' 或 \`1'。 (+) 它们具有与以前相同的格式； _op_ 可能是其中之一

**A**

上次文件访问时间，作为自纪元以来的秒数

**A:**

与 **A** 类似，但采用时间戳格式，例如 \`Fri May 14 16:36:10 1993'

**M**

上次文件修改时间

**M:**

与 **M** 类似，但采用时间戳格式

**C**

上次 inode 修改时间

**C:**

与 **C** 类似，但采用时间戳格式

**D**

设备编号

**I**

索引节点号

**F**

复合 **文件** 标识符，格式为 _device_:_inode_

**L**

符号链接指向的文件名

**N**

（硬）链接数

**P**

八进制的权限，不带前导零

**P:**

像 **P** ，前导零

**P_mode_**

等价于 \`-P _file_ & _mode_', 例如, \`-P22 _file_' 返回 \`22' 如果 _file_ 可以按组和其他方式写入， \`20' 如果只按组， \`0' 如果两者都不能

**P_mode_**:****

与 **P**_mode_ 类似，前导零

**U**

数字用户 ID

**U:**

用户名，如果用户名未知，则为数字用户 ID

**G**

数字组标识

**G:**

组名，如果组名未知，则为数字组 ID

**Z**

大小，以字节为单位

在多算子测试中只能出现这些算子中的一个，并且必须是最后一个。 请注意， **L** 在多操作员测试的末尾和其他地方具有不同的含义。 因为 \`0' 是许多这些运算符的有效返回值，所以它们在失败时不会返回 \`0' ：大多数返回 \`-1'，而 **F** 返回 \`:'。

如果 shell 是使用定义的 POSIX 编译的（请参阅 **version** shell 变量），则文件查询的结果基于文件的权限位，而不是 _access_(2) 系统调用的结果。 例如，如果使用 **\-w** 测试一个文件，该文件的权限通常允许写入但位于只读安装的文件系统上，则测试将在 POSIX shell 中成功，但在非 POSIX shell 中失败。

文件查询运算符也可以使用 _filetest_ 内置命令 (qv) (+) 进行评估。

[工作](#__u5DE5___u4F5C_)
-----------------------

Shell 将 _job_ 与每个管道相关联。 它保存一个由 _jobs_ 命令打印的当前作业表，并为它们分配小的整数。 当使用 \`&' 异步启动作业时，shell 会打印一行，如下所示

\[1\] 1234

表示异步启动的作业编号为 1，并且有一个（顶级）进程，其进程 ID 为 1234。

如果您正在运行一项工作并希望做其他事情，您可以点击暂停键（通常是 \`^Z'), 它会向当前工作发送一个停止信号。 然后外壳程序通常会指示该作业已被“暂停”并打印另一个提示。 如果设置了 **listjobs** 变量，所有作业都将像 _jobs_ 内置命令一样被列出；如果设置为 \`long' ，列表将采用长格式，如 \`jobs -l'。 然后，您可以操纵暂停作业的状态。 你可以用 _bg_ 命令把它放到 \`\`background'' ，或者运行一些其他的命令，最后用 _fg_ 把这个工作带回到 \`\`foreground''。 （另请参见 _run-fg-editor_ 编辑器命令。) \`^Z' 立即生效，就像一个中断，挂起的输出和未读的输入在键入时被丢弃。 _wait_ 内置命令使 shell 等待所有后台作业完成。

\`^\]' 键向当前作业发送延迟挂起信号，该信号在程序尝试 _read_(2) 它之前不会生成 STOP 信号。 当您为某项作业准备了一些命令并希望在读取它们后停止这些命令时，提前键入该命令很有用。 \`^Y' 键在 _csh_(1) 中执行此功能；在 _tcsh_ 中，\`^Y' 是一个编辑命令。 (+)

如果尝试从终端读取，则在后台运行的作业将停止。 后台作业通常被允许产生输出，但可以通过给出命令 \`stty tostop' 来禁用它。 如果您设置此 tty 选项，则后台作业将在它们尝试生成输出时停止，就像它们尝试读取输入时一样。

有几种方法可以在 shell 中引用作业。 字符 \`%' 引入了一个作业名称。 如果你想引用作业号 1，你可以将它命名为 \`%1' 。 只需命名一项工作即可将其置于前台；因此 \`%1' 是 \`fg %1'的同义词，将作业 1 带回前台。 类似地，说 \`%1 &' 会在后台恢复作业 1，就像 \`bg %1'一样。 作业也可以通过键入的字符串的明确前缀来命名以启动它：如果只有一个名称以字符串 \`ex' 开头的暂停作业， \`%ex' 通常会重新启动暂停的 _ex_(1) 作业。 如果只有一个这样的作业，也可以说 \`%?_string_' 来指定其文本包含 _string_ 的作业。

shell 维护当前和以前的作业的概念。 在与作业有关的输出中，当前作业用 \`+' 标记，前一个作业用 \`-' 标记。 缩写 \`%+'、 \`%' 和（类比 _历史_ 机制的语法) \`%%' 都是指当前的工作，而 \`%-' 指的是之前的工作。

作业控制机制要求在某些系统上设置 _stty_(1) 选项 \`new' 。 它是 tty 驱动程序的 \`new' 实现的产物，它允许从键盘生成中断字符来告诉作业停止。 有关在新 tty 驱动程序中设置选项的详细信息，请参阅 _stty_(1) 和 _setty_ 内置命令。

[状态报告](#__u72B6___u6001___u62A5___u544A_)
-----------------------------------------

每当进程更改状态时，shell 会立即学习。 它通常会在作业被阻止时通知您，以便无法取得进一步的进展，但只会在打印提示之前通知您。 这样做是为了不干扰您的工作。 但是，如果您设置 shell 变量 **notify** ，shell 将立即通知您后台作业的状态更改。 还有一个 shell 命令 _notify_ 标记单个进程，以便立即报告其状态更改。 默认情况下，通知 _notify_ 当前进程；启动后台作业后只需说 \`notify' 即可对其进行标记。

当您在作业停止时尝试离开 shell 时，您将收到警告 \`There are suspended jobs' 。 您可以使用 _jobs_ 命令查看它们是什么。 如果您这样做或立即尝试再次退出，shell 将不会再次警告您，并且暂停的作业将被终止。

[自动、定期和定时事件 (+)](#__u81EA___u52A8___u3001___u5B9A___u671F___u548C___u5B9A___u65F6___u4E8B___u4EF6__(+))
-------------------------------------------------------------------------------------------------------

在 shell 的 \`\`life cycle'' 中，有多种方法可以在不同时间自动运行命令和执行其他操作。它们在这里进行了总结，并在相应的 **Builtin commands**、 **Special shell variables** 和 **Special aliases** 下进行了详细描述。

_sched_ 内置命令将命令放在计划事件列表中，以便在给定时间由 shell 执行。

_beepcmd_、 _cwdcmd_、 _periodic_、 _precmd_、 _postcmd_ 和 _jobcmd_ **Special aliases** ，在 shell 要响铃时、工作目录变化时、每 **tperiod** 分钟、每条提示之前、每条命令之前执行命令被执行，在每个命令被执行之后，当一个作业被启动或被带到前台时。

可以将 **autologout** shell 变量设置为在给定的不活动分钟数后注销或锁定 shell。

**mail** shell 变量可以设置为定期检查新邮件。

可以设置 **printexitvalue** 变量以打印以非零状态退出的命令的退出状态。

**rmstar** shell 变量可以设置为询问用户，当键入 \`rm \*' 时，这是否真的是这个意思。

**time** shell 变量可以设置为在完成任何花费超过给定 CPU 秒数的进程后执行 _time_ 内置命令。

**watch** 和 **who** 变量可以设置为在选定用户登录或注销时报告，并且 _log_ 内置命令随时报告这些用户。

[母语系统支持 (+)](#__u6BCD___u8BED___u7CFB___u7EDF___u652F___u6301__(+))
-------------------------------------------------------------------

shell 是 8 位干净的（如果这样编译；请参阅 **version** shell 变量），因此支持需要此功能的字符集。 NLS 支持因 shell 是否被编译为使用系统的 NLS 而有所不同（再次参见 **version**)。 在任何一种情况下，7 位 ASCII 是默认字符代码（例如，哪些字符可打印的分类）和排序，更改 **LANG** 或 **LC\_CTYPE** 环境变量会导致检查这些方面可能发生的变化。

当使用系统的 NLS 时，调用 _setlocale_(3) 函数来确定适当的字符代码/分类和排序（例如， 'en\_CA.UTF-8' 将产生 "UTF-8" 作为字符代码）。 该函数通常检查 **LANG** 和 **LC\_CTYPE** 环境变量；有关详细信息，请参阅系统文档。 当不使用系统的 NLS 时，shell 通过假设无论何时设置 **LANG** 和 **LC\_CTYPE** 变量中的任何一个都使用 ISO 8859-1 字符集来模拟它，而不管它们的值如何。 模拟 NLS 的排序不受影响。

此外，无论是真实的还是模拟的 NLS， \\200-\\377 范围内的所有可打印字符，即具有 M-_char_ 绑定的字符，都会自动反弹到 _self-insert-command_ 。 转义 _char_ 序列的相应绑定（如果有）将保持不变。 如果设置了 **NOREBIND** 环境变量，这些字符不会被重新绑定。 这对于模拟 NLS 或假定完整 ISO 8859-1 的原始真实 NLS 可能很有用。 否则， \\240-\\377 范围内的所有 M-_char_ 绑定都将有效地撤消。 当然，使用 _bindkey_ 显式重新绑定相关键仍然是可能的。

未知字符（即，既不能打印也不能控制字符）以 \\nnn 格式打印。 如果 tty 不是 8 位模式，则通过将其他 8 位字符转换为 ASCII 并使用突出模式来打印它们。 shell 从不更改 tty 的 7/8 位模式，并跟踪用户启动的 7/8 位模式更改。 NLS 用户（或者想使用元密钥的用户）可能需要通过适当的 _stty_(1) 命令将 tty 显式设置为 8 位模式，例如 _~/.login_ 文件。

[操作系统变体支持 (+)](#__u64CD___u4F5C___u7CFB___u7EDF___u53D8___u4F53___u652F___u6301__(+))
-------------------------------------------------------------------------------------

提供了许多新的内置命令来支持特定操作系统中的功能。 **内置命令** 部分详细描述了所有内容。

在支持 TCF（aix-ibm370、aix-ps2）的系统上， _getspath_ 和 _setspath_ 获取和设置系统执行路径， _getxvers_ 和 _setxvers_ 获取和设置实验版本前缀和 _migrate_ 在站点之间迁移进程。 内置 _jobs_ 打印每个作业正在执行的站点。

在BS2000下， _bs2cmd_ 执行底层 BS2000/OSD 操作系统的命令。

在 Domain/OS 下， _inlib_ 将共享库添加到当前环境， _rootnode_ 更改 rootnode， _ver_ 更改 systype。

在 Mach 下， _setpath_ 等价于 Mach 的 _setpath_(1)。

在 Masscomp/RTU 和 Harris CX/UX 下， _universe_ 设定了宇宙。

在 Harris CX/UX 下， _ucb_ 或 _att_ 在指定的 Universe 下运行命令。

在 Convex/OS 下， _warp_ 打印或设置宇宙。

**VENDOR**、 **OSTYPE** 和 **MACHTYPE** 环境变量分别表示 shell 认为它正在运行的系统的供应商、操作系统和机器类型（微处理器类或机器模型）。 当在几种类型的机器之间共享一个人的主目录时，这些特别有用；例如，一个可以

set path = (~/bin.$MACHTYPE /usr/ucb /bin /usr/bin .)

在一个 _~/.login_ 中，并将为每台机器编译的可执行文件放在适当的目录中。

**version** 变量指示编译 shell 时选择了哪些选项。

还要注意内置的 _newgrp_ 、 **afsuser** 和 **echo\_style** 变量以及 shell 输入文件的系统相关位置（请参阅 **文件**)。

[信号处理](#__u4FE1___u53F7___u5904___u7406_)
-----------------------------------------

登录 shell 在读取文件 _~/.logout_ 时会忽略中断。 除非以 **\-q** 开头，否则 shell 会忽略退出信号。登录 shell 捕获终止信号，但非登录 shell 从其父级继承终止行为。 其他信号具有外壳从其父级继承的值。

在 shell 脚本中，shell 对中断和终止信号的处理可以用 _onintr_ 控制，它对挂断的处理可以用 _hup_ 和 _nohup_。

shell 在挂断时退出（另请参见 **logout** shell 变量）。 默认情况下，shell 的子进程也会这样做，但 shell 在退出时不会向它们发送挂断消息。 _hup_ 安排外壳在退出时向孩子发送挂断， _nohup_ 设置孩子忽略挂断。

[终端管理 (+)](#__u7EC8___u7AEF___u7BA1___u7406__(+))
-------------------------------------------------

shell 使用三组不同的终端（\`\`tty''）模式：'edit'，在编辑时使用， \`quote'，在引用文字字符时使用，以及在执行命令时使用的 \`execute'。 shell 在每个模式中保持一些设置不变，因此使 tty 处于混乱状态的命令不会干扰 shell。 shell 还匹配 tty 的速度和填充的变化。 可以使用 _setty_ 内置命令检查和修改保持不变的 tty 模式列表。 请注意，尽管编辑器使用 CBREAK 模式（或其等效模式），但它还是需要预先输入的字符。

_echotc_、 _settc_ 和 _telltc_ 命令可用于从命令行操作和调试终端功能。

在支持 SIGWINCH 或 SIGWINDOW 的系统上，shell 会自动调整窗口大小并调整环境变量 **LINES** 和 **COLUMNS** （如果已设置）。 如果环境变量 **TERMCAP** 包含 li# 和 co# 字段，shell 会调整它们以反映新的窗口大小。

[参考](#__u53C2___u8003_)
=======================

本手册的下一部分描述了所有可用的 **内置命令**、 **特殊别名** 和 **特殊 shell 变量**。

[内置命令](#__u5185___u7F6E___u547D___u4EE4_)
-----------------------------------------

**%_job_**

_fg_ 内置命令的同义词。

**%_job_ **&****

_bg_ 内置命令的同义词。

**:**

什么都不做，成功了。

**@**-
**@ _name_ **=** _expr_**-
**@ _name_\[_index_\] **=** _expr_**-
**@ _name_**++**|**\--****

**@ _name_\[_index_\]**++**|**\--****

第一种形式打印所有 shell 变量的值。

第二种形式将 _expr_ 的值赋给 _name_。 第三种形式将 _expr_ 的值分配给 _name_ 的第 _index_ 个组件； _name_ 和它的第 _index_ 个组件必须已经存在。

_expr_ 可以包含操作符 \`\*'、 \`+' 等，就像在 C 中一样。 如果 _expr_ 包含 \`<'、 \`>'、 \`&' 或 \`' 则至少 _expr_ 的那部分必须放在 \`()' 中。 请注意， _expr_ 的语法与 **Expressions** 中描述的无关。

第四种和第五种形式递增 (\`++') 或递减 (\`--') _name_ 或其第 _index_ 个组件。

\`@' 和 _name_ 之间的空格是必需的。 _name_ 和 \`=' 之间以及 \`=' 和 _expr_ 之间的空格是可选的。 _expr_ 的组成部分必须用空格分隔。

**alias \[_name_ \[_wordlist_\]\]**

没有参数，打印所有别名。 使用 _name_ ，打印名称的别名。 使用 _name_ 和 _wordlist_ ，将 _wordlist_ 指定为 _name_ 的别名。 _wordlist_ 命令和文件名替换。 _name_ 不能是 \`alias' 或 \`unalias'。 另请参见 _unalias_ 内置命令。

**alloc**

显示获取的动态内存量，分为已用内存和可用内存。 使用参数显示每个大小类别中空闲和已使用块的数量。 类别从 8 号开始，每一步加倍。 此命令的输出可能因系统类型而异，因为 VAX 以外的系统可能使用不同的内存分配器。

**bg \[**%**_job_ ...\]**

将指定的作业（或不带参数的当前作业）放入后台，如果停止则继续每个作业。 _job_ 可以是数字、字符串、 \`'、 \`%'、 \`+' 或 \`-' ，如 **Jobs** 中所述。

**bindkey \[**\-l**|**\-d**|**\-e**|**\-v**|**\-u**\] (+)**-
**bindkey** \[**\-a**\] \[**\-b**\] \[**\-k**\] \[**\-r**\] \[**\--**\] _key_ (+)

**bindkey** \[**\-a**\] \[**\-b**\] \[**\-k**\] \[**\-c**|**\-s**\] \[**\--**\] _key command_ (+)

如果没有选项，第一种形式列出所有绑定的键和每个绑定到的编辑器命令，第二种形式列出 _key_ 绑定到的编辑器命令，第三种形式将编辑器命令 _command_ 绑定到 _key_。 选项包括：

**\-l**

列出所有编辑器命令和每个命令的简短描述。

**\-d**

按照下面的 **\-e** 和 **\-v** 将所有键绑定到默认编辑器的标准绑定。

**\-e**

将所有键绑定到 _emacs_(1) 样式的绑定。取消设置 **vimode**。

**\-v**

将所有键绑定到 _vi_(1) 样式的绑定。 设置 **vimode**。

**\-a**

列出或更改备用键映射中的键绑定。 这是 **vimode** 命令模式中使用的键映射。

**\-b**

_key_ 被解释为控制字符写为 ^_character_ (例如， \`^A') 或 C-_character_ (例如， \`C-A') ，元字符写成 M-_character_ (例如， \`M-A'), 功能键写成 F-_string_ (例如， \`F-string'), 或扩展的前缀键写入 X-_character_ (例如， \`X-A')。

**\-k**

_key_ 被解释为一个符号箭头键名称，它可以是 \`down'、 \`up'、 \`left' 或 \`right'。

**\-r**

删除 _key_ 的绑定。 请注意： \`bindkey -r' _不会_ 将 _key_ 绑定到 _self-insert-command_ (qv)，它会完全取消绑定 _key_ 。

**\-c**

_command_ 被解释为内置或外部命令，而不是编辑器命令。

**\-s**

_command_ 被视为文字字符串，并在键入 _key_ 时被视为终端输入。 _command_ 中的绑定键本身会被重新解释，这会持续十个解释级别。

**\--**

强制中断选项处理，因此即使下一个单词以 '-' 开头，它也会被视为 _key_。

**\-u (or any invalid option)**

打印使用信息。

_key_ 可以是单个字符或字符串。 如果命令绑定到字符串，则字符串的第一个字符绑定到 _sequence-lead-in_ ，整个字符串绑定到命令。

_key_ 中的控制字符可以是文字（可以通过在它们前面加上编辑器命令 _quoted-insert_ 来键入，通常绑定到 \`^V') 或书面插入字符样式，例如 \`^A' 。 删除写成 \`^?' 插入问号）。 _key_ 和 _command_ 可以包含反斜杠转义序列（采用 System V _echo_(1) 的样式），如下所示：

**\\a**

钟

**\\b**

退格

**\\e**

逃脱

**\\f**

换页

**\\n**

换行

**\\r**

回车

**\\t**

水平制表

**\\v**

垂直制表

**\\_nnn_**

八进制数 _nnn_ 对应的 ASCII 字符

\`\\' 使后面的字符的特殊含义无效，如果它有的话，特别是 \`\\' 和 \`^'。

**bs2cmd _bs2000-command_ (+)**

将 _bs2000-command_ t传递给 BS2000 命令解释器执行。 只能执行非交互式命令，并且不能执行任何会覆盖当前进程映像的命令，例如 /EXECUTE 或 /CALL-PROCEDURE 。（仅限 BS2000）

**break**

导致执行在最近的封闭 _foreach_ 或 _while_ _结束_ 后恢复。 执行当前行上的剩余命令。 因此，通过将它们全部写在一行上，可以实现多级中断。

**breaksw**

导致 _switch_ 中断，在 _endsw_ 后恢复。

**builtins (+)**

打印所有内置命令的名称。

**bye (+)**

_logout_ 内置命令的同义词。 仅当 shell 如此编译时才可用；查看 **version** shell 变量。

**case _label_**:****

_switch_ 语句中的标签，如下所述。

**cd \[**\-p**\] \[**\-l**\] \[**\-n**|**\-v**\] \[I--\] \[_name_\]**

如果给出了目录 _name_ ，则将 shell 的工作目录更改为 _name_ 。 如果不是，则更改为 **home** ，除非未设置 **cdtohome** 变量，在这种情况下需要名称。 如果 _name_ 是 \`-' 它被解释为以前的工作目录（参见 **其他替换**)。 (+) 如果 _name_ 不是当前目录的子目录（并且不以 \`/'、 \`./' 或 \`../' 开头），则检查变量 **cdpath** 的每个组件以查看它是否具有子目录 _name_ 。 最后，如果所有其他方法都失败了，但 _name_ 是一个 shell 变量，其值以 \`/' 或 '.' 开头，则尝试查看它是否是一个目录，并且隐含了 **\-p** 选项。

使用 **\-p** ，打印最终的目录堆栈，就像 _dirs_ 。 **\-l**、 **\-n** 和 **\-v** 标志对 _cd_ 的作用与对 _dirs_ 的作用相同，它们暗含 **\-p**。 (+) 使用 **\--** 强制中断选项处理，因此下一个单词被视为目录 _name_ ，即使它以 '-' 开头。 (+)

另请参见 **implicitcd** 和 **cdtohome** shell 变量。

**chdir**

_cd_ 内置命令的同义词。

**complete \[_command_ \[_word_**/**_pattern_**/**_list_\[**:**_select_\]**/**\[\[_suffix_\]**/**\] ...\]\] (+)**

没有参数，列出所有完成。 使用 _command_ ，列出 _command_ 的完成。 使用 _command_ 和 _word_ 等，定义完成。

_command_ 可以是完整的命令名称或 glob 模式（请参阅 **文件名替换**) 。 它可以以 \`-' 开头，表示仅在命令不明确时才应使用补全。

_word_ 指定相对于当前单词要完成的单词，并且可以是以下之一：

**c**

当前单词完成。 _pattern_ 是一个全局模式，它必须匹配命令行上当前单词的开头。 完成当前单词时忽略 _pattern_ 。

**C**

与 **c** 类似，但在完成当前单词时包含 _pattern_ 。

**n**

下一个单词完成。 _pattern_ 是一个全局模式，它必须匹配命令行上前一个单词的开头。

**N**

与 **n** 类似，但必须匹配当前单词前两个单词的开头。

**p**

位置相关的完成。 _pattern_ 是一个数字范围，与用于索引 shell 变量的语法相同，它必须包括当前单词。

_list_ ，可能完成的列表，可能是以下之一：

**a**

别名

**b**

绑定（编辑器命令）

**c**

命令（内置或外部命令）

**C**

以提供的路径前缀开头的外部命令

**d**

目录

**D**

以提供的路径前缀开头的目录

**e**

环境变量

**f**

文件名

**F**

以提供的路径前缀开头的文件名

**g**

组名

**j**

工作

**l**

限制

**n**

没有

**s**

Shell 变量

**S**

信号

**t**

纯 (\`\`text'') 文件

**T**

以提供的路径前缀开头的纯 (\`\`text'') 文件

**v**

任何变量

**u**

用户名

**x**

与 **n** 类似，但在使用 _list-choices_ 时打印 _select_ 。

**X**

完成

$_var_

来自变量 _var_ 的单词

(...)

给定列表中的单词

\`...\`

命令输出中的单词

_select_ 是一个可选的全局模式。 如果给定，则仅考虑与 _select_ 匹配的 _list_ 中的单词，并忽略 **fignore** shell 变量。 最后三种补全类型可能没有 _select_ 模式， **x** 在使用 _list-choices_ 编辑器命令时使用 _select_ 作为解释性消息。

_suffix_ 是要附加到成功完成的单个字符。 如果为 null，则不附加任何字符。 如果省略（在这种情况下也可以省略第四个分隔符），则将斜杠附加到目录，并将空格附加到其他单词。

从 \`...\` 版本调用的 _command_ 具有附加的环境变量集，变量名称为 **COMMAND\_LINE** 并包含（如其名称所示）当前（已键入）命令行的内容。 可以在她的自定义脚本中检查和使用 **COMMAND\_LINE** 变量的内容来构建更复杂的补全（请参阅此包中包含的 svn(1) 补全）。

现在举一些例子。 有些命令只接受目录作为参数，所以完成纯文件是没有意义的。

\> complete cd 'p/1/d/'

仅用目录完成 \`cd' (\`p/1') 之后的第一个单词。 **p** 样式完成也可用于缩小命令完成的范围：

\> co\[^D\]-
complete compress-
\> complete -co\* 'p/0/(compress)/'-
\> co\[^D\]-
\> compress

这个补全完成了以 \`co' 开头的命令（位置 0 的词， \`p/0') （因此匹配 \`co\*') 到 \`compress' （列表中的唯一词）。 前导的 \`-' 表示这个补全仅用于模棱两可的命令。

\> complete find 'n/-user/u/'

是 **n** 样式补全的一个例子。 \`find' 之后和 \`-user' 之后的任何单词都是从用户列表中完成的。

\> complete cc 'c/-I/d/'

演示 **c** 类型的完成。 \`cc' 之后并以 \`-I' 开头的任何单词都作为目录完成。 \`-I' 没有作为目录的一部分，因为我们使用了小写 **c**。

不同的 _list_ 对不同的命令很有用。

\> complete alias 'p/1/a/'-
\> complete man 'p/\*/c/'-
\> complete set 'p/1/s/'-
\> complete true 'p/1/x:Truth has no options./'

这些完整的单词在 \`alias' 后面带有别名，在 \`man' 后面带有命令，而在 \`set' 后面带有 shell 变量。 \`true' 没有任何选项，因此 **x** 在尝试完成时什么都不做，并打印 \`Truth has no options.' 当列出完成选项时。

请注意， _man_ 示例和下面的其他几个示例也可以使用 'c/\*' 或 'n/\*' 作为 'p/\*'。

单词可以从完成时评估的变量中完成，

\> complete ftp 'p/1/$hostnames/'-
\> set hostnames = (rtfm.mit.edu tesla.ee.cornell.edu)-
\> ftp \[^D\]-
rtfm.mit.edu tesla.ee.cornell.edu-
\> ftp \[^C\]-
\> set hostnames = (rtfm.mit.edu tesla.ee.cornell.edu uunet.uu.net)-
\> ftp \[^D\]-
rtfm.mit.edu tesla.ee.cornell.edu uunet.uu.net

或从完成时运行的命令：

\> complete kill 'p/\*/\`ps | awk \\{print\\ \\$1\\}\`/'-
\> kill -9 \[^D\]-
23113 23377 23380 23406 23429 23529 23530 PID

请注意， _complete_ 的命令本身并不引用它的参数，因此必须明确引用 \`{print $1}' 中的大括号、空格和 \`$' 。

一个命令可以有多个完成：

\> complete dbx 'p/2/(core)/' 'p/\*/c/'

使用单词 \`core' 完成 \`dbx' 的第二个参数，并使用命令完成所有其他参数。 请注意，位置完成是在下一个单词完成之前指定的。 因为补全是从左到右评估的，如果首先指定下一个单词补全，它将始终匹配并且永远不会执行位置补全。 这是定义完成时的常见错误。

当命令将仅具有特定形式的文件作为参数时， _select_ 模式很有用。例如，

\> complete cc 'p/\*/f:\*.\[cao\]/'

完成仅以 \`.c'、 \`.a' 或 \`.o' 结尾的文件的 \`cc' 参数。 _select_ 也可以排除文件，使用 glob 模式的否定，如 **文件名替换**. 中所述。 一个人可能会使用

\> complete rm 'p/\*/f:^\*.{c,h,cc,C,tex,1,man,l,y}/'

从 \`rm' 完成中排除宝贵的源代码。 当然，仍然可以手动键入排除的名称或使用 _complete-word-raw_ 或 _list-choices-raw_ 编辑器命令 (qv) 覆盖完成机制。

\`C'、 \`D'、 \`F' 和 \`T' _列表_ 分别类似于 \`c'、 \`d'、 \`f' 和 \`t'，但它们以不同的方式使用 _select_ 参数：限制完成到以特定路径前缀开头的文件。 例如，Elm 邮件程序使用 \`=' 作为邮件目录的缩写。一个人可能会使用

\> complete elm c@=@F:$HOME/Mail/@

完成 \`elm -f =' 就好像它是 \`elm -f ~/Mail/'。 请注意，我们使用 \`@' 而不是 \`/' 以避免与 _select_ 参数混淆，并且我们使用 \`$HOME' 而不是 \`~' 因为主目录替换仅在单词的开头起作用。

_suffix_ 用于为完成的单词添加非标准后缀（不是空格或目录的 \`/' ) 。

\> complete finger 'c/\*@/$hostnames/' 'p/1/u/@'

完成用户列表中 \`finger' 的参数，附加一个 \`@', 然后在 \`hostnames' 变量的 \`@' 之后完成。 再次注意指定完成的顺序。

最后，这是一个复杂的灵感示例：

\> complete find \\-
'n/-name/f/' 'n/-newer/f/' 'n/-{,n}cpio/f/' \\-
´n/-exec/c/' 'n/-ok/c/' 'n/-user/u/' \\-
'n/-group/g/' 'n/-fstype/(nfs 4.2)/' \\-
'n/-type/(b c d f l p s)/' \\-
´c/-/(name newer cpio ncpio exec ok user \\-
group fstype type atime ctime depth inum \\-
ls mtime nogroup nouser perm print prune \\-
size xdev)/' \\-
'p/\*/d/'

这完成了 \`-name'、 \`-newer'、 \`-cpio' 或 \`ncpio' （注意匹配两者的模式）到文件，在 \`-exec' 或 \`-ok' 之后的词到命令，在 \`user' 和 \`group' 分别表示用户和组，而 \`-fstype' 或 \`-type' 之后的单词表示给定列表的成员。 它还完成给定列表中的切换（注意使用 **c** 类型完成）并完成任何未完成的目录。

请记住，如果正在完成的单词是波浪号替换（以 \`~'开头）或变量（以 \`$' 开头），则程序完成将被忽略。 另请参阅 _uncomplete_ 的内置命令。

**continue**

继续执行最近的封闭 _while_ 或 _foreach_。 执行当前行的其余命令。

**default:**

在 _switch_ 语句中标记默认情况。 它应该出现在所有 _case_ 标签之后。

**dirs \[**\-l**\] \[**\-n**|**\-v**\]**-
**dirs -S|**\-L** \[_filename_\] (+)**

**dirs -c (+)**

第一种形式打印目录堆栈。 堆栈的顶部在左侧，堆栈中的第一个目录是当前目录。 使用 **\-l** ，输出中的 \`~' 或 \`~_name_' 将显式扩展为 **home** 或用户 _name_ 的主目录路径名。 (+) 使用 **\-n** ，条目在到达屏幕边缘之前被换行。 (+) 使用 **\-v** ，每行打印一个条目，前面是它们的堆栈位置。 (+) 如果给出了多个 **\-n** 或 **\-v** 之一，则 **\-v** 优先。 **\-p** 被接受但什么也不做。

使用 **\-S** ，第二种形式将目录堆栈保存为 _filename_ 作为一系列 _cd_ 和 _pushd_ 命令。 使用 **\-L**, shell 源 _filename_, 它可能是由 **\-S** 选项或 **savedirs** 机制保存的目录堆栈文件。 在任何一种情况下，如果未给出 _filename_ ，则使用 **dirsfile** ；如果未设置 **dirsfile** ，则使用 _~/.cshdirs_ 。

请注意，登录 shell 在启动时执行相当于 \`dirs -L' 的操作，如果设置了 **savedirs** ，则在退出前执行 \`dirs -S' 。 因为通常只有 _~/.tcshrc_ 位于 _~/.cshdirs_ 之前，所以应该在 _~/.tcshrc_ 而不是 _~/.login_ 中设置 **dirsfile** 。

最后一种形式清除目录堆栈。

**echo \[**\-n**\] _word_ ...**

将每个 _word_ 写入 shell 的标准输出，以空格分隔并以换行符结束。 **echo\_style** 变量可以设置为模拟（或不模拟）BSD 和/或 System V 版本的 _echo_ 的标志和转义序列；见 _echo_(1)。

**echotc \[**\-sv**\] _arg_ ... (+)**

在 _args_ 中练习终端功能（请参阅 _termcap_(5)) 。 例如， 'echotc home' 将光标发送到起始位置， 'echotc cm 3 10' 将光标发送到第 3 列和第 10 行， 'echotc ts 0; echo "This is a test."; echotc fs' 在状态栏中打印 "This is a test." 。

如果 _arg_ 是 'baud'、 'cols'、 'lines'、 'meta' 或 'tabs'，则打印该能力的值（"yes" 或 "no" 表示终端具有或不具有该能力）。 人们可能会使用它来使 shell 脚本的输出在慢速终端上不那么冗长，或者将命令输出限制为屏幕上的行数：

\> set history=\`echotc lines\`-
\> @ history--

Termcap 字符串可能包含无法正确回显的通配符。 在将 shell 变量设置为终端功能字符串时，应使用双引号，如下例所示，将日期放在状态行中：

\> set tosl="\`echotc ts 0\`"-
\> set frsl="\`echotc fs\`"-
\> echo -n "$tosl";date; echo -n "$frsl"

使用 **\-s** ，不存在的功能返回空字符串而不是导致错误。 使用 **\-v**, 消息是冗长的。

**else**-
**end**-
**endif**

**endsw**

请参阅下面的 _foreach_、 _if_、 _switch_ 和 _while_ 语句的描述。

**eval _arg_ ...**

将参数视为 shell 的输入，并在当前 shell 的上下文中执行生成的命令。 这通常用于执行作为命令或变量替换结果生成的命令，因为解析发生在这些替换之前。 有关 _eval_ 的示例使用，请参见 _tset_(1) 。

**exec _command_**

代替当前 shell 执行指定的命令。

**exit \[_expr_\]**

shell 以指定的 _expr_ （表达式，如 **Expressions** 中所述）的值退出，或者在没有 _expr_ 的情况下以值 0 退出。

**fg \[**%**_job_ ...\]**

将指定的作业（或不带参数的当前作业）置于前台，如果停止则继续每个作业。 _job_ 可以是数字、字符串、 \`'、 \`%'、 \`+' 或 \`-' ，如 **Jobs** 中所述。另请参见 _run-fg-editor_ 编辑器命令。

**filetest -_op file_ ... (+)**

将 _op_ 它是 **文件查询运算符** 中所述的文件查询运算符）应用于每个 _file_ ，并将结果作为空格分隔的列表返回。

**foreach _name_ **(**_wordlist_**)****-
...

**end**

依次为 _wordlist_ 的每个成员设置变量 _name_ ，并执行该命令与匹配 _end_ 之间的命令序列。 (_foreach_ 和 _end_ 都必须单独出现在不同的行上。) 内置命令 _continue_ 可用于过早地继续循环，内置命令 _break_ 可用于过早地终止循环。 当从终端读取这个命令时，循环会被读取一次，提示 \`foreach? '（或 **prompt2**) 在循环中的任何语句被执行之前。 如果您在终端输入循环时出错，您可以将其擦掉。

**getspath (+)**

打印系统执行路径。 （仅限 TCF）

**getxvers (+)**

打印实验版本前缀。 （仅限 TCF）

**glob _wordlist_**

与 _echo_ 类似，但无法识别 \`-n' 参数，并且输出中的单词由空字符分隔。 对于希望使用 shell 文件名扩展单词列表的程序很有用。

**goto _word_**

_word_ 是文件名和命令替换以产生形式为 \`label'的字符串。 shell 尽可能回退它的输入，搜索 \`label:'形式的行，前面可能有空格或制表符，并在该行之后继续执行。

**hashstat**

打印一条统计信息行，指示内部哈希表在定位命令（并避免执行 _exec_ ）方面的有效性。对于 **path** 中哈希函数指出可能命中的每个组件，以及每个不以 \`/' 开头的组件，尝试执行 _exec_ 。

在没有 _vfork_(2) 的机器上，只打印散列桶的数量和大小。

**history \[**\-hTr**\] \[_n_\]**-
**history -S|**\-L|****\-M** \[_filename_\] (+)**

**history -c (+)**

第一种形式打印历史事件列表。 如果给出 _n_ ，则仅打印或保存 _n_ 个最近的事件。 使用 **\-h**, 打印历史列表时不带前导数字。如果指定了 **\-T** ，时间戳也会以注释形式打印。 （这可用于生成适合使用 'history -L' 或 'source -h' 加载的文件。） 使用 **\-r** ，打印的顺序是最近的在前，而不是最旧的在前。

使用 **\-S** ，第二种形式将历史列表保存到 _filename_ 。 如果 **savehist** shell 变量的第一个单词设置为一个数字，最多可以保存那么多行。 如果 **savehist** 的第二个单词设置为 \`merge'，历史列表将与现有历史文件合并而不是替换它（如果有的话）并按时间戳排序。 (+) 合并适用于像 X Window 系统这样同时使用多个 shell 的环境。如果 **savehist** 的第二个词是 \`merge' 并且第三个词设置为 \`lock'，历史文件更新将与可能希望同时合并历史的其他 shell 会话序列化。

使用 **\-L** ，shell 将 _filename_ （可能是通过 **\-S** 选项或 **savehist** 机制保存的历史列表）附加到历史列表中。 **\-M** 与 **\-L** 类似，但 _filename_ 的内容被合并到历史列表中，并按时间戳排序。 在任何一种情况下，如果未给出 _filename_ ，则使用 **histfile** ；如果未设置 **histfile** ，则使用 _~/.history_ 。 \`history -L' 和 'source -h' 完全一样，只是它不需要文件名。

请注意，登录 shell 在启动时执行相当于 \`history -L' 的操作，如果设置了 **savehist** ，则在退出前执行 \`history -S' 。 因为通常只有 _~/.tcshrc_ 位于 _~/.history_ 之前，所以 **histfile** 应该设置在 _~/.tcshrc_ 而不是 _~/.login_ 中。

如果设置了 **histlit** ，则第一种和第二种形式打印并保存历史列表的文字（未扩展）形式。

最后一个表单清除历史列表。

**hup \[_command_\] (+)**

使用 _command_，运行 _command_ ，使其在挂断信号时退出，并安排外壳在外壳退出时向其发送挂断信号。 请注意，命令可能会设置自己对挂断的响应，覆盖 _hup_。 如果没有参数，则导致非交互式 shell 仅在脚本其余部分挂断时退出。 另请参阅 **信号处理** 和 _nohup_ 内置命令。

**if (_expr_**)** _command_**

如果 _expr_ 一个表达式，如 **表达式** 中所述）计算结果为 true，则执行 _command_ 。 _command_ 上的变量替换很早就发生了，同时它对 _if_ 命令的其余部分也发生了。 _command_ 必须是一个简单的命令，而不是别名、管道、命令列表或带括号的命令列表，但它可能有参数。 即使 _expr_ 为 false 并且 _不会_ 执行 _command_ ，也会发生输入/输出重定向；这是一个错误。

**if (_expr_**) then****-
...-
**else if (_expr2_**) then****-
...-
**else**-
...

**endif**

如果指定的 _expr_ 为真，则执行第一个 _else_ 的命令；否则，如果 _expr2_ 为真，则执行第二个 _else_ 的命令，依此类推。 任何数量的 _else-if_ 都是可能的；只需要一个 _endif_ 。 _else_ 部分同样是可选的。（单词 _else_ 和 _endif_ 必须出现在输入行的开头； _if_ 必须单独出现在其输入行上或 _else_ 之后。）

**inlib _shared-library_ ... (+)**

将每个 _shared-library_ 添加到当前环境。 无法删除共享库。（仅限 Domain/OS)

**jobs \[**\-l**\]**

列出活动作业。 使用 **\-l** ，除普通信息外，还列出进程 ID。 在 TCF 系统上，打印执行每个作业的站点。

**kill \[**\-s** _signal_\] **%**_job_|_pid_ ...**

**kill -l**

第一种和第二种形式将指定的 _signal_ 或者，如果没有给出，则 TERM（终止）信号）发送到指定的作业或进程。 _job_ 可以是数字、字符串、 \`'、 \`%'、 \`+' 或 \`-' as ，如 **Jobs** 中所述。 信号要么由编号给出，要么由名称给出（如 _/usr/include/signal.h_ 中给出的，去掉前缀 \`SIG')。 没有默认作业；只说 \`kill' 不会向当前 _job_ 发送信号。 如果发送的信号是 TERM（终止）或 HUP（挂断），那么作业或进程也会发送一个 CONT（继续）信号。 第三种形式列出了信号名称。

**limit \[**\-h**\] \[_resource_ \[_maximum-use_\]\]**

将当前进程及其创建的每个进程的消耗限制为不超过指定 _resource_ 的 _maximum-use_ 。 如果没有给出 _maximum-use_ ，则打印当前限制；如果没有给定 _resource_ ，则给出所有限制。 如果给出 **\-h** 标志，则使用硬限制而不是当前限制。 硬限制对当前限制的值施加了上限。 只有超级用户可以提高硬限制，但用户可以在合法范围内降低或提高当前限制。

当前可控资源包括（如果操作系统支持）：

_cputime_

每个进程使用的最大 cpu 秒数

_filesize_

可以创建的最大单个文件

_datasize_

通过 sbrk(2) 超出程序文本末尾的数据+堆栈区域的最大增长

_stacksize_

自动扩展堆栈区域的最大大小

_coredumpsize_

将创建的最大核心转储的大小

_memoryuse_

进程在给定时间可能分配给它的最大物理内存量

_vmemoryuse_

进程在给定时间（地址空间）可能分配给它的最大虚拟内存量

_vmemoryuse_

进程在给定时间可能分配给它的最大虚拟内存量

_heapsize_

进程可以为每个 _brk()_ 系统调用分配的最大内存量

_descriptors_ 或 _openfiles_

此进程的最大打开文件数

_pseudoterminals_

此用户的最大伪终端数

_kqueues_

分配给该进程的最大 kqueue 数

_concurrency_

此进程的最大线程数

_memorylocked_

进程可以使用 mlock(2) 锁定到内存的最大大小

_maxproc_

此用户 ID 的最大同时进程数

_maxthread_

此用户 ID 的最大并发线程数（轻量级进程）

_threads_

此进程的最大线程数

_sbsize_

该用户使用的最大套接字缓冲区大小

_swapsize_

为该用户保留或使用的最大交换空间量

_maxlocks_

此用户的最大锁定数

_posixlocks_

此用户的 POSIX 咨询锁的最大数量

_maxsignal_

该用户的最大挂起信号数

_maxmessage_

此用户的 POSIX mqueues 中的最大字节数

_maxnice_

允许用户将此用户从 \[19...-20\] 映射到 \[0...39\] 的最大优先级

_maxrtprio_

此用户的最大实时优先级 _maxrttime_ 此用户的 RT 任务超时时间（以微秒为单位）。

_maximum-use_ 可以以（浮点或整数）数字的形式给出，后跟比例因子。 对于除 _cputime_ 之外的所有限制，默认比例为“k”或“千字节”（1024 字节）；也可以使用“m”或“兆字节”或“g”或“千兆字节”的比例因子。 对于 _cputime_ t默认的缩放比例是 \`seconds'，而 \`m' 表示分钟或 \`h' 表示小时，或者可以使用给出分钟和秒的 \`mm:ss' 形式的时间。

如果 _maximum-use_ 是 \`unlimited', 那么对指定 _resource_ 的限制被移除（这相当于 _unlimit_ 内置命令）。

对于 _resource_ 名称和比例因子，名称的明确前缀就足够了。

**log (+)**

打印 **watch** shell 变量并报告 **watch** 中指示的每个登录用户，无论他们上次登录的时间。 另见 _watchlog_。

**login**

终止登录 shell，将其替换为 _/bin/login_ 的实例。 这是一种注销方式，包括与 _sh_(1) 兼容。

**logout**

终止登录 shell 。 如果设置了 **ignoreeof** 尤其有用。

**ls-F \[-_switch_ ...\] \[_file_ ...\] (+)**

列出像 \`ls -F' 这样的文件，但要快得多。它用特殊字符标识列表中的每种特殊文件类型：

/

目录

\*

可执行文件

#

块设备

%

字符设备

|

命名管道（仅具有命名管道的系统）

\=

套接字（仅限套接字的系统）

@

符号链接（仅具有符号链接的系统）

+

隐藏目录（仅限 AIX）或上下文相关（仅限 HP/UX）

:

网络专用（仅限 HP/UX）

如果设置了 **listlinks** shell 变量，则会更详细地识别符号链接（当然，仅在具有它们的系统上）：

@

指向非目录的符号链接

\>

指向目录的符号链接

&

无处的符号链接

**listlinks** 也会减慢 _ls-F_ 的速度，并导致挂载符号链接指向的文件的分区。

如果 **listflags** 变量设置为 \`x'、 \`a' 或 \`A' 或它们的任何组合（例如， \`xA'), 它们将用作 _ls-F_ 的标志，使其行为类似于 \`ls -xF'、 \`ls -Fa'、 \`ls -FA' 或组合（例如， \`ls -FxA')。 在 \`ls -C' 不是默认值的机器上， _ls-F_ 的行为类似于 \`ls -CF' ，除非 **listflags** 包含 \`x', 在这种情况下它的行为类似于 \`ls -xF'。 如果给定任何开关， _ls-F_ 会将其参数传递给 _ls_(1) ，因此 \`alias ls ls-F' 通常会做正确的事情。

**ls-F** 内置可以根据文件类型或扩展名使用不同颜色列出文件。 请参阅 **color** shell 变量和 **LS\_COLORS** 环境变量。

**migrate \[**\-**_site_\] _pid_|**%**_jobid_ ... (+)**

**migrate -_site_ (+)**

第一种形式将进程或作业迁移到指定的站点或由系统路径确定的默认站点。 第二种形式相当于 \`migrate -_site_ $$': 将当前进程迁移到指定站点。 迁移 shell 本身可能会导致意外行为，因为 shell 不喜欢丢失它的 tty。 （仅限 TCF）

**newgrp \[**\-**\] _\[group\]_ (+)**

相当于 \`exec newgrp'; 参见 _newgrp_(1) 。仅当 shell 如此编译时才可用；查看 **version** shell 变量。

**nice \[**+**_number_\] \[_command_\]**

将 shell 的调度优先级设置为 _number_ ，或者，如果没有 _number_ ，设置为 4。 使用 _command_ ，以适当的优先级运行 _command_ 。 _number_ 越大，进程获得的 cpu 越少。 超级用户可以使用 \`nice -number ...' 指定负优先级。 命令总是在子 shell 中执行，并且适用于简单 _if_ 语句中的命令的限制。

**nohup \[_command_\]**

使用 _command_ ，运行 _command_ 以忽略挂断信号。 请注意，命令可能会设置自己对挂断的响应，覆盖 _nohup_ 。 如果没有参数，则导致非交互式 shell 仅忽略脚本其余部分的挂断。 另请参阅 **信号处理** 和 _hup_ 内置命令。

**notify \[**%**_job_ ...\]**

当任何指定作业（或者，没有 %_job_ ，当前作业）的状态发生更改时，使 shell 异步通知用户，而不是像往常一样等到下一个提示。 _job_ 可以是数字、字符串、 \`'、 \`%'、 \`+' 或 \`-' a，如 **Jobs** 中所述。 另请参见 **notify** shell 变量。

**onintr \[**\-**|_label_\]**

控制 shell 对中断的操作。 不带参数，恢复 shell 对中断的默认操作，即终止 shell 脚本或返回到终端命令输入级别。 使用 \`-'会导致忽略所有中断。 使用 _label_ ，当接收到中断或子进程因中断而终止时，shell 会执行 \`goto _label_' 。

如果 shell 以分离方式运行并且在系统启动文件中运行（请参阅 **文件**)，则忽略 _onintr_ ，无论如何都禁用中断。

**popd \[**\-p**\] \[**\-l**\] \[**\-n**|**\-v**\] \[**+**_n_\]**

没有参数，弹出目录堆栈并返回到新的顶层目录。 使用数字 \`+_n_' ，丢弃堆栈中的第 _n_ 个条目。

最后，所有形式的 _popd_ 都会打印最终的目录堆栈，就像 _dirs_ 一样。 可以设置 **pushdsilent** shell 量来防止这种情况发生，并且可以给出 **\-p** 标志来覆盖 **pushdsilent** 。 **\-l**、 **\-n** 和 **\-v** 标志对 _popd_ 的影响与对 _dirs_ 的影响相同。 (+)

**printenv \[_name_\] (+)**

打印所有环境变量的名称和值，或者使用 _name_ 打印环境变量 _name_ 的值。

**pushd \[**\-p**\] \[**\-l**\] \[**\-n**|**\-v**\] \[_name_|**+** _n_\]**

没有参数，交换目录堆栈的顶部两个元素。 如果设置了 **pushdtohome** ，不带参数的 _pushd_ 会执行 \`pushd ~',如 _cd_。 (+) 使用 _name_ ，将当前工作目录推入目录堆栈并更改 _name_。 如果 _name_ 是 \`-' 它被解释为以前的工作目录（参见 **文件名替换**)。 (+) 如果设置了 **dunique** , _pushd_ 会在将 _name_ 的任何实例推入堆栈之前从堆栈中删除它。 (+) 使用数字 \`+_n_' ，将目录堆栈的第 _n_ 个元素旋转到顶部元素并更改为它。 但是，如果设置了 **dextract** ，则 \`pushd +_n_' 提取第 _n_ 个目录，将其推送到堆栈顶部并更改为它。 (+)

最后，所有形式的 _pushd_ 都会打印出最终的目录栈，就像 _dirs_ 一样。 可以设置 **pushdsilent** 变量来防止这种情况发生，并且可以给出 **\-p** 标志来覆盖 **pushdsilent** 。 **\-l**、 **\-n** 和 **\-v** 标志对 _pushd_ 的影响与对 _dirs_ 的影响相同。 (+)

**rehash**

导致重新计算 **path** 变量中目录内容的内部哈希表。 如果未设置 **autorehash** shell 变量并且在您登录时将新命令添加到 **path** 中的目录中，则需要这样做。 使用 **autorehash** ，将自动找到新命令，除非在哈希表中已存在位于不同目录中的另一个同名命令的特殊情况。 还刷新由波浪号扩展构建的主目录的缓存。

**repeat _count command_**

指定的 _command_ 与上面一行 _if_ 语句中的 _command_ 有相同的限制，执行 _count_ 次。 I/O 重定向只发生一次，即使 _count_ 为 0。

**rootnode //_nodename_ (+)**

将根节点更改为 //_nodename_, 这样 \`/' 将被解释为 \`//_nodename_'。 (仅限 Domain/OS)

**sched (+)**-
**sched \[**+**\]_hh:mm command_ (+)**

**sched -_n_ (+)**

第一种形式打印预定事件列表。 可以设置 **sched** shell 变量来定义打印预定事件列表的格式。 第二种形式将 _command_ 添加到预定事件列表。 例如，

\> sched 11:00 echo It\\'s eleven o\\'clock.

导致 shell 回显 \`It's eleven o'clock.' 在上午 11 点。 时间可能是 12 小时 AM/PM 格式

\> sched 5pm set prompt='\[%h\] It\\'s after 5; go home: >'

或者可能相对于当前时间：

\> sched +2:15 /usr/lib/uucp/uucico -r1 -sother

相对时间规范可能不使用 AM/PM 格式。 第三种形式从事件列表中删除项目 _n_ :

\> sched 1 Wed Apr 4 15:42 /usr/lib/uucp/uucico -r1 -sother 2 Wed Apr 4 17:00 set prompt=\[%h\] It's after 5; go home: >-
\> sched -2-
\> sched 1 Wed Apr 4 15:42 /usr/lib/uucp/uucico -r1 -sother

计划事件列表中的命令在计划命令的时间之后打印第一个提示之前执行。 可能会错过运行命令的确切时间，但会在下一个提示符处执行过期的命令。 在 shell 等待用户输入时到期的命令会立即执行。 然而，已经运行的命令的正常操作不会被中断，从而可以运行预定事件列表元素。

这种机制与某些 Unix 系统上的 _at_(1) 命令相似，但又不同。 它的主要缺点是它可能不会在指定的时间运行命令。 它的主要优点是因为 _sched_ 直接从 shell 运行，它可以访问 shell 变量和其他结构。 这提供了一种根据一天中的时间改变工作环境的机制。

**set**-
**set _name_ ...**-
**set _name_**\=**_word_ ...**-
**set \[-r\] \[-f|-l\] _name_**\=(**_wordlist_**)** ... (+)**-
**set _name\[index\]_**\=**_word_ ...**-
**set -r (+)**-
**set -r _name_ ... (+)**

**set -r _name_**\=**_word_ ... (+)**

命令的第一种形式打印所有 shell 变量的值。 包含多个单词的变量打印为带括号的单词列表。 第二种形式将 _name_ 设置为空字符串。 第三种形式将 _name_ 设置为单个单词。 第四种形式将 _name_ 设置为 _wordlist_ 中的单词列表。 在所有情况下，该值都是命令和文件名扩展。 如果指定了 **\-r** ，则将该值设置为只读。 如果指定了 **\-f** 或 **\-l** ，则仅设置保持其顺序的唯一单词。 **\-f** 喜欢单词的第一次出现， **\-l** t最后出现。 第 5 种形式将 _name_ 的第 _index_ 个组件设置为 _word_; 该组件必须已经存在。 第六种形式只列出所有只读的 shell 变量的名称。 第七种形式使 _name_ 只读，无论它是否有值。 第八种形式与第三种形式相同，但同时将 _name_ 设为只读。

可以重复这些参数以在单个 set 命令中设置和/或使多个变量只读。 但是请注意，在任何设置发生之前，所有参数都会发生变量扩展。 另请注意， \`=' 可以与 _name_ 和 _word_ 相邻，也可以由空格分隔，但不能仅与一个或另一个相邻。 另请参阅 _unset_ 内置命令。

**setenv \[_name_ \[_value_\]\]**

不带参数，打印所有环境变量的名称和值。 给定 _name_ ，将环境变量 _name_ 设置为 _value_ ，或者在没有 _value_ 的情况下设置为空字符串。

**setpath _path_ (+)**

等效于 _setpath_(1) 。（仅限Mach)

**setspath LOCAL|_site_|_cpu_ ... (+)**

设置系统执行路径。 （仅限 TCF）

**settc _cap value_ (+)**

告诉 shell 相信终端能力 _cap_ (定义在 _termcap_(5) 中) 具有值 _value_ 。 没有进行完整性检查。 概念终端用户可能需要 \`settc xn no' 才能在最右边的列正确换行。

**setty \[**\-d**|**\-q**|**\-x**\] \[**\-a**\] \[\[**+**|**\-**\]_mode_\] (+)**

控制 shell 不允许更改的 tty 模式（请参阅 **终端管理**)。 **\-d**、 **\-q** 或 **\-x** 告诉 _setty_ 分别对 \`edit'、 \`quote' 或 \`execute' tty 模式集进行操作；如果没有 **\-d**、 **\-q** 或 **\-x** ，则使用 \`execute' 。

在没有其他参数的情况下， _setty_ 列出了所选集中固定为 (\`+mode') 或关闭 (\`-mode')的模式。 可用模式以及显示因系统而异。 使用 **\-a** ，列出所选集中的所有 tty 模式，无论它们是否固定。 使用 **+**_mode_、 **\-**_mode_ 或 _mode_, 固定 _mode_ 打开或关闭或从所选集中的 _mode_ 中删除控制。 例如， \`setty +echok echoe' 修复了 \`echok' 模式，并允许命令在 shell 执行命令时打开或关闭 \`echoe' 模式。

**setxvers \[_string_\] (+)**

将实验版本前缀设置为 _string_ ，如果省略 _string_ ，则将其删除。 （仅限 TCF）

**shift \[_variable_\]**

没有参数，丢弃 **argv**\[1\] 并将 **argv** 的成员向左移动。 不设置 **argv** 或将少于一个单词作为值是错误的。 使用 _variable_ ，对 _variable_ 执行相同的功能。

**source \[**\-h**\] _name_ \[_args_ ...\]**

shell 从 _name_ 读取并执行命令。 这些命令不会放在历史列表中。 如果给定了任何 _args_ ，它们将被放置在 **argv** 中。 (+) _source_ 命令可以嵌套；如果它们嵌套得太深，shell 可能会用完文件描述符。 任何级别的 _source_ 中的错误都会终止所有嵌套的 _source_ 命令。 使用 **\-h** ，命令被放置在历史列表中而不是被执行，很像 \`history -L' 。

**stop **%**_job_|_pid_ ...**

停止在后台执行的指定作业或进程。 _job_ 可以是数字、字符串、 \`'、 \`%'、 \`+' 或 \`-' ，如 **Jobs** 中所述。 没有默认 _job_; 只说 \`stop' 并不会停止当前的工作。

**suspend**

使 shell 停止在其轨道上，就像它已通过 **^Z** 发送停止信号一样。 这最常用于停止由 _su_(1) 启动的 shell。

**switch (_string_**)****-
**case _str1_**:****

...-
**breaksw**

...

**default:**

...-
**breaksw**

**endsw**

每个案例标签都连续匹配，与指定的 _string_ 匹配，该字符串是第一个命令和文件名扩展。 文件元字符 \`\*'、 \`?' 和 \`\[...\]' 可以用在 case 标签中，它们是可变扩展的。 如果在找到 \`default' 标签之前没有任何标签匹配，则在默认标签之后开始执行。 每个案例标签和默认标签必须出现在一行的开头。 命令 _breaksw_ 导致在 _endsw_ 之后继续执行。 否则控制可能会像 C 中一样通过大小写标签和默认标签。 如果没有标签匹配并且没有默认值，则在 _endsw_ 之后继续执行。

**telltc (+)**

列出所有终端功能的值（请参阅 _termcap_(5))。

**termname \[_terminal type_\] (+)**

测试 _terminal type_ （如果没有给出 _terminal type_ ，则测试 **TERM** 的当前值）在主机 termcap(5) 或 terminfo(5) 数据库中是否有条目。 将终端类型打印到标准输出，如果存在条目则返回 0，否则返回 1。

**time \[_command_\]**

执行 _command_ (必须是简单命令，而不是别名、管道、命令列表或带括号的命令列表）并打印 **time** 变量下描述的时间摘要。 如有必要，将创建一个额外的 shell 以在命令完成时打印时间统计信息。 如果没有 _command_ ，则打印当前 shell 及其子 shell 的时间摘要。

**umask \[_value_\]**

将文件创建掩码设置为 _value_ ，以八进制给出。 掩码的常见值为 002，授予对组的所有访问权限以及对其他人的读取和执行权限，以及 022，授予对组和其他人的读取和执行权限。 没有 _value_ ，打印当前文件创建掩码。

**unalias _pattern_**

-
删除名称与 _pattern_ 匹配的所有别名。 \`unalias \*' 因此删除所有别名。 没有任何东西是 _unalias_ ，这不是错误。

**uncomplete _pattern_ (+)**

删除名称匹配 _pattern_ 的所有完成。 \`uncomplete \*' 因此删除所有完成。 没有任何事情 _uncomplete_ 并不是错误。

**unhash**

禁止使用内部散列表来加速执行程序的定位。

**universe _universe_ (+)**

将 universe 设置为 _universe_。 (仅限 Masscomp/RTU)

**unlimit \[**\-hf**\] \[_resource_\]**

删除对 _resource_ 的限制，或者如果未指定 _resource_ ，则删除所有 _resource_ 限制。 使用 **\-h** ，删除相应的硬限制。只有超级用户可以这样做。 请注意， **unlimit** 可能不会成功退出，因为大多数系统不允许 _descriptors_ 不受限制。 使用 **\-f** 错误将被忽略。

**unset _pattern_**

删除名称与 _pattern_ 匹配的所有变量，除非它们是只读的。 \`unset \*' 因此删除所有变量，除非它们是只读的；这是一个坏主意。 没有东西被 _unset_ 不是错误。

**unsetenv _pattern_**

删除名称匹配 _pattern_ 的所有环境变量。 \`unsetenv \*' 因此删除所有环境变量；这是一个坏主意。 没有什么是 _unsetenv_，这不是错误。

**ver \[_systype_ \[_command_\]\] (+)**

不带参数，打印 **SYSTYPE** 。 使用 _systype_ ，将 **SYSTYPE** 设置为 _systype_ 。 使用 _systype_ 和 _command_，执行 _systype_ 下的 _command_ 命令。 _systype_ 可以是 \`bsd4.3' 或 \`sys5.3'。 (仅限 Domain/OS)

**wait**

shell 等待所有后台作业。如果 shell 是交互式的，中断将中断等待并导致 shell 打印所有未完成作业的名称和作业编号。

**warp _universe_ (+)**

将 universe 设置为 _universe_。 (仅限 Convex/OS)

**watchlog (+)**

_log_ 内置命令 (qv) 的备用名称。 仅当 shell 如此编译时才可用；查看 **version** shell 变量。

**where _command_ (+)**

报告所有已知的 _command_ 实例，包括 **path** 中的别名、内置命令和可执行文件。

**which _command_ (+)**

显示在替换、 **path** 搜索等之后将由 shell 执行的命令。 内置命令就像 _which_(1) 一样，但它正确报告 _tcsh_ 别名和内置命令，并且速度快 10 到 100 倍。 另请参阅 _which-command_ 编辑器命令。

**while (_expr_**)****-
...

**end**

执行 _while_ 和匹配 _end_ 之间的命令，而 _expr_ （一个表达式，如 **Expressions** 中所述）计算非零。 _while_ 和 _end_ 必须单独出现在它们的输入行上。 _break_ 和 _continue_ 可用于提前终止或继续循环。 如果输入是终端，则在第一次通过循环时提示用户，就像使用 _foreach_ 一样。

[特殊的别名 (+)](#__u7279___u6B8A___u7684___u522B___u540D__(+))
----------------------------------------------------------

如果设置，这些别名中的每一个都会在指定的时间自动执行。 它们最初都是未定义的。

**beepcmd**

当 shell 想要敲响终端铃声时运行。

**cwdcmd**

每次更改工作目录后运行。 例如，如果用户正在使用 _xterm_(1) 和支持标题栏（如 _twm_(1) 的重新父窗口管理器在 X 窗口系统上工作，并且

\> alias cwdcmd 'echo -n "^\[\]2;${HOST}:$cwd ^G"'

然后 shell 会将正在运行的 _xterm_(1) 的标题更改为主机名、冒号和完整的当前工作目录。 一种更好的方法是

\> alias cwdcmd 'echo -n "^\[\]2;${HOST}:$cwd^G^\[\]1;${HOST}^G"'

这会将主机名和工作目录放在标题栏上，但仅将主机名放在图标管理器菜单中。

请注意，在 _cwdcmd_ 中放置 _cd_、 _pushd_ 或 _popd_ 可能会导致无限循环。 作者认为，任何这样做的人都会得到他们应得的。

**jobcmd**

在每个命令执行之前或命令更改状态时运行。 这类似于 _postcmd_ ，但它不打印内置命令。

\> alias jobcmd 'echo -n "^\[\]2\\;\\!#:q^G"'

然后执行 _vi foo.c_ 会将命令字符串放在 xterm 标题栏中。

**helpcommand**

由 **run-help** 编辑器命令调用。 寻求帮助的命令名称作为唯一参数传递。 例如，如果一个人

\> alias helpcommand '\\!:1 --help'

然后将调用命令本身的帮助显示，使用 GNU 帮助调用约定。 目前没有简单的方法来解释各种调用约定（例如，习惯的 Unix \`-h'），除非使用包含许多命令的表。

**periodic**

每 **tperiod** 分钟运行一次。 这为检查常见但不频繁的更改（例如新邮件）提供了一种方便的方法。 例如，如果一个人

\> set tperiod = 30-
\> alias periodic checknews

然后 _checknews_(1) 程序每 30 分钟运行一次。 如果设置了 _periodic_ 但未设置 **tperiod** 或设置为0，则 _periodic_ 的行为类似于 _precmd_。

**precmd**

在打印每个提示之前运行。 例如，如果一个人

\> alias precmd date

然后 _date_(1) 在 shell 提示每个命令之前运行。 _precmd_ 可以设置的内容没有限制，但应谨慎使用。

**postcmd**

在每个命令执行之前运行。

\> alias postcmd 'echo -n "^\[\]2\\;\\!#:q^G"'

然后执行 _vi foo.c_ 会将命令字符串放在 xterm 标题栏中。

**shell**

为本身不指定解释器的可执行脚本指定解释器。 第一个单词应该是所需解释器的完整路径名（例如， \`/bin/csh' 或 \`/usr/local/bin/tcsh')。

[特殊 shell 变量](#__u7279___u6B8A__shell___u53D8___u91CF_)
-------------------------------------------------------

本节中描述的变量对 shell 具有特殊意义。

shell 设置 **addsuffix**, **argv**, **autologout**, **csubstnonl**, **command**, **echo\_style**, **edit**, **gid**, **group**, **home**, **loginsh**, **oid**, **path**, **prompt**, **prompt2**, **prompt3**, **shell**, **shlvl**, **tcsh**, **term**, **tty**, **uid**, **user** and **version** 启动时；除非用户更改，否则它们此后不会更改。 shell 会在必要时更新 **cwd**, **dirstack**, **owd** 和 **status** ，并在注销时设置 **logout** 。

shell 将 **group**, **home**, **path**, **shlvl**, **term** 和 **user** 与同名的环境变量同步：每当环境变量更改时，shell 都会更改相应的 shell 变量以匹配（除非 shell 变量是只读的），反之亦然. 请注意，虽然 **cwd** 和 **PWD** 具有相同的含义，但它们并不以这种方式同步，并且 shell 会自动在 **path** 和 **PATH**。

**addsuffix (+)**

如果设置，文件名补全会在目录末尾添加 \`/' ，并在正常文件完全匹配时在正常文件末尾添加一个空格。 默认设置。

**afsuser (+)**

如果设置， **autologout** 的自动锁定功能将使用其值而不是本地用户名进行 kerberos 身份验证。

**ampm (+)**

如果设置，所有时间都以 12 小时 AM/PM 格式显示。

**anyerror (+)**

此变量选择传播到 **status** 变量值的内容。 有关更多信息，请参阅下面的 **status** 变量描述。

**argv**

shell 的参数。 位置参数取自 **argv**, 即 \`$1' 被 \`$argv\[1\]' 替换，等等。 默认设置，但在交互式 shell 中通常为空。

**autocorrect (+)**

如果设置， _spell-word_ 编辑器命令会在每次完成尝试之前自动调用。

**autoexpand (+)**

如果设置， _expand-history_ 编辑器命令会在每次完成尝试之前自动调用。 如果设置为 _onlyhistory_, 则仅扩展历史记录，第二次补全将扩展文件名。

**autolist (+)**

如果设置，则在模棱两可的完成后列出可能性。如果设置为 'ambiguous'，则仅当补全未添加新字符时才会列出可能性。

**autologout (+)**

第一个词是在自动注销之前不活动的分钟数。 可选的第二个字是自动锁定之前不活动的分钟数。 当 shell 自动注销时，它会打印 \`auto-logout'，将变量 **logout** 设置为 \`automatic' 并退出。 当外壳自动锁定时，用户需要输入密码才能继续工作。 五次不正确的尝试会导致自动注销。 在登录和超级用户 shell 中默认设置为 “60”（60 分钟后自动注销，并且不锁定），但如果 shell 认为它在窗口系统下运行（即设置了 **DISPLAY** 环境变量），则不设置是一个伪 tty (pty) 或者 shell 不是这样编译的（参见 **version** shell 变量）。 另请参见 **afsuser** 和 **logout** shell 变量。

**autorehash (+)**

如果设置，如果在哈希表中找不到命令，则将重新计算 **path** 变量中目录内容的内部哈希表。 此外，如果分别设置为 \`complete' 或 \`correct' ，将为每个命令完成或拼写更正尝试重建可用命令列表；如果设置为 \`always' ，这将在两种情况下完成。

**backslash\_quote (+)**

如果设置，反斜杠 (\`\\') 总是引用 \`\\'、 \`'' 和 \`"' 。这可能会使复杂的引用任务变得更容易，但可能会导致 _csh_(1) 脚本中的语法错误。

**catalog**

消息目录的文件名。如果设置，tcsh 使用 \`tcsh.${catalog}' 作为消息目录，而不是默认的 \`tcsh'。

**cdpath**

如果在当前目录中找不到子目录， _cd_ 应该在其中搜索子目录的目录列表。

**cdtohome (+)**

如果没有设置， _cd_ 需要一个目录 _name_ ，如果省略它就不会进入 **home** 目录。 这是默认设置的。

**color**

如果设置，它将启用内置 **ls-F** 的彩色显示，并将 **\--color=auto** 传递给 **ls**或者，可以将其设置为仅 **ls-F** 或仅 **ls** 以仅对一个命令启用颜色。 将其设置为空等效于将其设置为 **(ls-F ls)**。

**colorcat**

如果设置，它将启用 NLS 消息文件的颜色转义序列。 并显示丰富多彩的 NLS 消息。

**command (+)**

如果设置，则使用 **\-c** 标志 (qv) 传递给 shell 的命令。

**compat\_expr (+)**

如果设置，shell 将从右到左计算表达式，就像原始的 _csh_ 一样。

**complete (+)**

如果设置为 'igncase'，完成变得不区分大小写。 如果设置为 \`enhance'，完成忽略大小写并认为连字符和下划线是等价的；它还将句点、连字符和下划线 (\`.'、 \`-' 和 \`\_') 视为单词分隔符。 如果设置为 \`Enhance'，补全显式匹配大写和下划线字符，并以不区分大小写的方式匹配小写和连字符；它将句点、连字符和下划线视为单词分隔符。 继续 (+) 如果设置为命令列表，shell 将继续列出的命令，而不是开始新的命令。

**continue (+)**

如果设置为命令列表，shell 将继续列出的命令，而不是开始新的命令。

**continue\_args (+)**

与 continue 相同，但 shell 将执行：

echo \`pwd\` $argv > ~/.<cmd>\_pause; %<cmd>

**correct (+)**

如果设置为 \`cmd' ，命令会自动进行拼写更正。 如果设置为 \`complete', 命令将自动完成。 如果设置为 \`all'，则更正整个命令行。

**csubstnonl (+)**

如果设置，命令替换中的换行符和回车符将被空格替换。 默认设置。

**cwd**

当前目录的完整路径名。 另请参见 **dirstack** 和 **owd** shell 变量。

**dextract (+)**

如果设置， \`pushd +_n_' 从目录堆栈中提取第 _n_ 个目录，而不是将其旋转到顶部。

**dirsfile (+)**

\`dirs -S' 和 \`dirs -L' 查找历史文件的默认位置。 如果未设置，则使用 _~/.cshdirs_ 。因为通常只有 _~/.tcshrc_ 位于 _~/.cshdirs_ 之前，所以应该在 _~/.tcshrc_ 而不是 _~/.login_ 中设置 **dirsfile** 。

**dirstack (+)**

目录堆栈上所有目录的数组。 \`$dirstack\[1\]' 是当前工作目录， \`$dirstack\[2\]' 是堆栈上的第一个目录，等等。 请注意，当前工作目录是 \`$dirstack\[1\]' 但在目录堆栈替换等中为 \`=0' 。 可以通过设置 **dirstack** 任意更改堆栈，但第一个元素（当前工作目录）始终是正确的。 另请参见 **cwd** 和 **owd** shell 变量。

**dspmbyte (+)**

如果 'dspm' 被列为 **version** shell 变量的一部分，则有效。 如果设置为 \`euc'，则可以显示和编辑 EUC 汉字（日语）代码。 如果设置为 \`sjis', 它可以显示和编辑 Shift-JIS（日文）代码。 如果设置为 \`big5', 它可以显示和编辑Big5（中文）代码。 如果设置为 \`utf8', 它将启用显示和编辑 Utf8(Unicode) 代码。 如果设置为以下格式，则可以显示和编辑原始多字节码格式：

\> set dspmbyte = 0000....(256 bytes)....0000

该表 **just** 需要 256 个字节。256 个字符的每个字符对应（从左到右）ASCII 码 0x00、0x01、... 0xff。 每个字符设置为数字 0、1、2 和 3。 每个数字具有以下含义： 0 ... 不用于多字节字符。 1 ... 用于多字节字符的第一个字节。 2 ... 用于多字节字符的第二个字节。 3 ... 用于多字节字符的第一个字节和第二个字节。

实例:-
如果设置为 “001322”，则第一个字符（表示 ASCII 码的 0x00）和第二个字符（表示 ASCII 码的 0x01）设置为 “0”。 然后，它不用于多字节字符。 第 3 个字符 (0x02) 设置为 “1”，表示它用于多字节字符的第一个字节。 第 4 个字符 (0x03) 设置为 “3”。 它用于多字节字符的第一个字节和第二个字节。 第 5 和第 6 个字符 (0x04,0x05) 设置为 “2”，表示它们用于多字节字符的第二个字节。

如果没有 -N ( --literal ) 选项，GNU fileutils 版本的 ls 无法显示多字节文件名。 如果您使用此版本，请将 dspmbyte 的第二个字设置为 "ls"。 如果不是，例如， "ls-F -l" 不能显示多字节文件名。

笔记：-
只有在编译时定义了 KANJI 和 DSPMBYTE 时才能使用此变量。

**dunique (+)**

如果设置， _pushd_ 会在将 _name_ 推入堆栈之前从堆栈中删除任何实例。

**echo**

如果设置，则每个命令及其参数都会在执行之前回显。 对于非内置命令，所有扩展都发生在回显之前。 内置命令在命令和文件名替换之前回显，因为这些替换是选择性地完成的。 由 **\-x** 命令行选项设置。

**echo\_style (+)**

_echo_ 内置的样式。可以设置为

bsd

如果第一个参数是 \`-n'，则不要回显换行符； _csh_ 的默认值。

sysv

识别回显字符串中的反斜杠转义序列。

both

识别 \`-n' 标志和反斜杠转义序列； _tcsh_ 的默认值。

none

都不认识。

默认设置为本地系统默认值。 BSD 和 System V 选项在相应系统的 _echo_(1) 手册页中进行了描述。

**edit (+)**

如果设置，则使用命令行编辑器。在交互式 shell 中默认设置。

**editors (+)**

要匹配的 _run-fg-editor_ 编辑器命令的命令名称列表。 如果未设置，将使用 **EDITOR** (如果未设置，则为 \`ed' ) 和 **VISUAL** (如果未设置，则为 \`vi') 环境变量。

**ellipsis (+)**

如果设置， \`%c'/\`%.' 和 \`%C' 提示序列（参见 **prompt** shell variable) 变量）用省略号 (\`...') 而不是 \`/<skipped>' 表示跳过的目录。

**euid (+)**

用户的有效用户 ID。

**euser (+)**

与有效用户 ID 对应的第一个匹配的 passwd 条目名称。

**fignore (+)**

列出完成时要忽略的文件名后缀。

**filec**

在 _tcsh_ 中，始终使用完成，默认情况下忽略此变量。 如果未设置 **edit** ，则使用传统的 _csh_ 补全。 如果在 _csh_ 中设置，则使用文件名完成。

**gid (+)**

用户的真实组 ID。

**globdot (+)**

如果设置，通配符 glob 模式将匹配以 \`.' 开头的文件和目录 除了 \`.' 和 \`..'

**globstar (+)**

如果设置， \`\*\*' 和 \`\*\*\*' 文件 glob 模式将匹配任何字符串，包括遍历任何现有子目录的 \`/' 。 （例如， \`ls \*\*.c' 将列出当前目录树中的所有 .c 文件）。 如果单独使用，它将匹配零个或多个子目录（例如， \`ls /usr/include/\*\*/time.h' 将列出 /usr/include 目录树中名为 \`time.h' 的任何文件；而 \`ls /usr/include/\*\*time.h' 将匹配 /usr/include 目录树中以 \`time.h' 结尾的任何文件）。 为了防止递归问题， \`\*\*' 全局模式不会下降到包含目录的符号链接。要覆盖它，请使用 \`\*\*\*'

**group (+)**

用户的组名。

**highlight**

如果设置，增量搜索匹配（在 _i-search-back_ 和 _i-search-fwd_ 中）以及标记和光标之间的区域在反向视频中突出显示。

突出显示需要更频繁的终端写入，这会带来额外的开销。 如果您关心终端性能，您可能希望不设置此项。

**histchars**

确定 **历史替换** (qv) 中使用的字符的字符串值。 其值的第一个字符用作历史替换字符，替换默认字符 \`!' 。 其值的第二个字符在快速替换中替换字符 \`^' 。

**histdup (+)**

控制历史列表中重复条目的处理。 如果设置为 \`all',则仅在历史列表中输入唯一的历史事件。 如果设置为 \`prev' 并且最后一个历史事件与当前命令相同，则当前命令不会进入历史记录。 如果设置为 \`erase' 并且在历史列表中找到相同的事件，则该旧事件将被擦除并插入当前事件。 请注意， \`prev' 和 \`all' 选项对历史事件重新编号，因此没有间隔。

**histfile (+)**

\`history -S' 和 \`history -L' 查找历史文件的默认位置。 如果未设置，则使用 _~/.history_ 。 **histfile** 在不同机器之间共享同一个主目录时很有用，或者在不同终端上保存单独的历史记录时很有用。 因为通常只有 _~/.tcshrc_ 位于 _~/.history_ 之前，所以 **histfile** 应该设置在 _~/.tcshrc_ 而不是 _~/.login_ 中。

**histlit (+)**

如果设置，内置和编辑器命令以及 **savehist** 机制使用历史列表中的文字（未扩展）形式的行。 另请参见 _toggle-literal-history_ 编辑器命令。

**history**

第一个字表示要保存的历史事件的数量。 可选的第二个字 (+) 表示打印历史的格式；如果没有给出，则使用 \`%h\\t%T\\t%R\\n' 。 格式序列在下面的**prompt** 下描述；注意 \`%R' 的变量含义。 默认设置为 \`100' 。

**home**

初始化到调用者的主目录。 \`_~_' 的文件名扩展指的是这个变量。

**ignoreeof**

如果设置为空字符串或 '0' 并且输入设备是终端，则 _end-of-file_ 命令（通常由用户在空行上键入 \`^D' 生成）会导致 shell 打印 \`Use "exit" to leave tcsh.' 而不是退出。这可以防止 shell 被意外杀死。 从历史上看，此设置在 26 次连续 EOF 后退出以避免无限循环。 如果设置为数字 _n_, shell 将忽略 _n - 1_ 个连续的 _end-of-file_ 并在第 _n_ 次退出。 (+) 如果未设置，则使用 \`1' ，即 shell 以单个 \`^D' 退出。

**implicitcd (+)**

如果设置，shell 将键入的目录名称视为命令，就好像它是更改到该目录的请求一样。 如果设置为 _verbose_ ，则目录的更改将回显到标准输出。 此行为在非交互式 shell 脚本中或对于包含多个单词的命令字符串中被禁止。 更改目录优先于执行同名命令，但它是在别名替换之后完成的。 波浪号和变量扩展按预期工作。

**inputmode (+)**

如果设置为 \`insert' 或 \`overwrite' ，则将编辑器置于每行开头的输入模式。

**killdup (+)**

控制终止环中重复条目的处理。 如果设置为 \`all' ，则只有唯一的字符串会被输入到 kill ring 中。 如果设置为 \`prev' 并且最后终止的字符串与当前终止的字符串相同，则当前字符串不会进入环中。 如果设置为 \`erase' 并且在 kill ring 中找到相同的字符串，则删除旧字符串并插入当前字符串。

**killring (+)**

指示要保留在内存中的已终止字符串的数量。 默认设置为 \`30' 。 如果未设置或设置为小于 \`2', shell 将只保留最近终止的字符串。 字符串由删除（杀死）文本字符串的编辑器命令（例如， _backward-delete-word_、 _kill-line_ 等）以及 _copy-region-as-kill_ 命令放入 killring 中。 _yank_ 编辑器命令会将最近终止的字符串拖入命令行，而 _yank-pop_ (请参阅 **编辑器命令**)可用于 yank 较早终止的字符串。

**listflags (+)**

如果设置为 \`x'、 \`a' 或 \`A' 或它们的任何组合（例如， \`xA')，它们将用作 _ls-F_ 的标志，使其行为类似于 \`ls -xF'、 \`ls -Fa'、 \`ls -FA' 或组合（例如， \`ls -FxA'): \`a' 显示所有文件（即使它们以 \`.'), \`A' 显示除 \`.' 之外的所有文件， \`..' 和 \`x' 排序而不是向下排序。 如果设置了 **listflags** 的第二个字，则将其用作 \`ls(1)' 的路径。

**listjobs (+)**

如果设置，则在暂停作业时列出所有作业。 如果设置为 \`long' ，则列表为长格式。

**listlinks (+)**

如果设置，则 _ls-F_ 内置命令显示每个符号链接指向的文件类型。

**listmax (+)**

_list-choices_ 编辑器命令将在不先询问的情况下列出的最大项目数。

**listmaxrows (+)**

_list-choices_ 编辑器命令将在不先询问的情况下列出的项目的最大行数。

**loginsh (+)**

如果是登录 shell，则由 shell 设置。 在 shell 中设置或取消设置它没有效果。 另见 **shlvl**。

**logout (+)**

在正常注销之前由 shell 设置为 \`normal' ，在自动注销之前设置为 \`automatic' ，如果 shell 被挂断信号杀死，则设置为 \`hangup' （参见 **信号处理**)。 另请参见 **autologout** shell 变量。

**mail**

用于检查传入邮件的文件和目录的列表，可以在前面加上一个数字单词。 在每次提示之前，如果距离上次检查已经过去了 10 分钟，shell 会检查每个文件并显示 \`You have new mail.' (或者，如果 **mail** 包含多个文件， \`You have new mail in _name_.') 如果文件大小大于零并且修改时间大于其访问时间。

如果您在登录 shell 中，则不会报告邮件文件，除非它在 shell 启动后被修改，以防止多余的通知。 大多数登录程序会在您登录时告诉您是否有邮件。

如果在 **mail** 中指定的文件是一个目录，shell 将把该目录中的每个文件计算为一个单独的消息，并报告 \`You have _n_ mails.' 或 \`You have _n_ mails in _name_.' 作为适当的。 此功能主要是为那些以这种方式存储邮件的系统提供的，例如 Andrew Mail System。

如果 **mail** 的第一个单词是数字，则将其视为不同的邮件检查间隔，以秒为单位。

在极少数情况下，shell 可能会报告 \`You have mail.' 而不是 \`You have new mail.'

**matchbeep (+)**

如果设置为 \`never'，完成不会发出哔哔声。 如果设置为 \`nomatch', 只有在没有匹配时才会发出哔哔声。 如果设置为 \`ambiguous', 当有多个匹配时它会发出哔哔声。 如果设置为 \`notunique', 当有一个完全匹配和另一个更长的匹配时，它会发出哔哔声。 如果未设置，则使用 \`ambiguous' 。

**nobeep (+)**

如果设置，哔哔声将完全禁用。 另见 **visiblebell**。

**noclobber**

如果设置，则对输出重定向施加限制，以确保文件不会被意外破坏，并且 \`>>' 重定向引用现有文件，如 **输入/输出** 部分所述。

**noding**

如果设置，禁用打印 \`DING!' 在时间变化的 **prompt** 时间说明符中。

**noglob**

如果设置， **Filename substitution** 和 **Directory stack substitution** (qv) 将被禁止。 这在不处理文件名的 shell 脚本中最有用，或者在获得文件名列表并且不需要进一步扩展之后。

**nokanji (+)**

如果设置并且 shell 支持 Kanji（请参阅 **version** shell 变量），它将被禁用，以便可以使用元键。

**nonomatch**

如果设置，，与任何现有文件不匹配的 **Filename substitution** 或 **Directory stack substitution** (qv) 将保持不变，而不是导致错误。 替换格式错误仍然是一个错误，例如， \`echo \[' 仍然给出错误。

**nostat (+)**

在完成操作期间不应 _stat_(2) 的目录列表（或匹配目录的 glob 模式；请参阅 **Filename substitution**）。 这通常用于排除需要花费太多时间来 _stat_(2) 的目录，例如 _/afs_。

**notify**

如果设置，shell 会异步宣布作业完成。 默认设置是在打印提示之前显示作业完成。

**oid (+)**

用户的真实组织 ID。 （仅限Domain/OS)

**owd (+)**

旧的工作目录，相当于 _cd_ 和 _pushd_ 使用的 \`-'。 另请参见 **cwd** 和 **dirstack** shell 变量。

**padhour**

如果设置，则启用以 24 和 12 小时格式打印小时的填充 '0' f。 例如： 07:45:42 与 7:45:42。

**parseoctal**

为了与旧版本兼容，以 0 开头的数字变量不会被解释为八进制。 设置此变量可启用正确的八进制解析。

**path**

在其中查找可执行命令的目录列表。 空字指定当前目录。 如果没有 **path** 变量，则只会执行完整路径名。 **path** 由 shell 在启动时从 **PATH** 环境变量设置，或者，如果 **PATH** 不存在，设置为依赖于系统的默认值，例如 \`(/usr/local/bin /usr/bsd /bin /usr/bin .)'。 shell 可能会放 \`.' **path** 中的第一个或最后一个或完全省略它，具体取决于它的编译方式；查看 **version** shell 变量。 一个既没有 **\-c** 也没有 **\-t** 选项的 shell 在读取 _~/.tcshrc_ 并且每次重置 **path** 后，都会对 **path** 中目录的内容进行哈希处理。 如果在 shell 处于活动状态时将新命令添加到 **path** 中的目录，则可能需要对 shell 进行 _rehash_ 以找到它。

**printexitvalue (+)**

如果设置并且交互式程序以非零状态退出，shell 将打印 \`Exit **status**'。

**prompt**

在从终端读取每个命令之前打印的字符串。 **prompt** 可能包含以下任何格式序列 (+)，它们将替换为给定的信息：

%/

当前工作目录。

%~

当前工作目录，但根据 **Filename substitution** ，一个人的主目录由 \`~' 表示，其他用户的主目录由 \`~user' 表示。只有当 shell 已经在当前会话的路径名中使用了 \`~_user_' 时，才会发生 \`~user' 替换。

%c\[\[0\]_n_\], %.\[\[0\]_n_\]

当前工作目录的尾随组件，如果给出数字 _n_ ，则为 _n_ 个尾随组件。 如果 _n_ 以 \`0' 开头，则跳过的组件数在格式 \`/<_skipped_\>trailing' 的尾随组件之前。 如果设置了 **ellipsis** shell 变量，则跳过的组件由省略号表示，因此整体变为 \`...trailing'。 \`~' 替换在上面的 \`%~' 中完成，但是在计算尾随组件时会忽略 \`~' 组件。

%C

与 %c 类似，但没有 \`~' 替换。

%h, %!, !

当前历史事件编号。

%M

完整的主机名。

%m

主机名直到第一个 \`.'。

%S (%s)

启动（停止）杰出模式。

%B (%b)

启动（停止）粗体模式。

%U (%u)

启动（停止）下划线模式。

%t, %@

12 小时 AM/PM 格式的时间。

%T

与 \`%t' 类似，但采用 24 小时格式（但请参见 **ampm** shell 变量）。

%p

以 12 小时 AM/PM 格式表示的 \`precise' 时间，以秒为单位。

%P

Like \`%p' 类似，但采用 24 小时格式（但请参见 **ampm** shell 变量）。

\\_c_

_c_ 被解析为在 _bindkey_ 中。

^_c_

_c_ 被解析为在 _bindkey_ 中。

%%

一个 \`%'。

%n

用户名。

%N

有效用户名。

%j

jobs 的数量。

%d

\`Day' 格式的工作日。

%D

\`dd' 格式的日期。

%w

\`Mon' 格式的月份。

%W

\`mm' 格式的月份。

%y

\`yy' 格式的年份。

%Y

\`yyyy' 格式的年份。

%l

shell 的 tty。

%L

从提示结束到显示结束或行结束清除。

%$

在 \`$' 之后立即展开 shell 或环境变量名称。

%#

\`>' (或 **promptchars** shell 变量的第一个字符）用于普通用户，\`#' (或 **promptchars** 的第二个字符）用于超级用户。

%{_string_%}

包括 _string_ 作为文字转义序列。 它应该仅用于更改终端属性，不应移动光标位置。 这不能是 **prompt** 中的最后一个序列。

%?

在提示符之前执行的命令的返回码。

%R

在 **prompt2** 中，解析器的状态。 在 **prompt3** 中，更正后的字符串。 在 **history** 中，历史字符串。

\`%B'、 \`%S'、 \`%U' 和 \`%{_string_%}' 仅在 eight-bit-clean shell 中可用；查看 **version** shell 变量。

粗体、突出和下划线序列通常用于区分超级用户 shell。 例如，

\> set prompt = "%m \[%h\] %B\[%@\]%b \[%/\] you rang? "-
tut \[37\] **\[2:54pm\]** \[/usr/accts/sys\] you rang? \_

如果使用了 \`%t'、 \`%@'、 \`%T'、 \`%p' 或 \`%P' 并且没有设置 **noding** ，则打印 \`DING!' 关于小时的变化（即 \`:00' 分钟）而不是实际时间。

在交互式 shell 中默认设置为 \`%# ' 。

**prompt2 (+)**

在 _while_ 和 _foreach_ 循环中以及以 \`\\' 结尾的行之后提示的字符串。 可以使用与 **prompt** (qv) 中相同的格式序列；注意 \`%R' 的变量含义。 默认设置为 \`%R? ' 在交互式 shells 中。

**prompt3 (+)**

确认自动拼写更正时提示的字符串。 可以使用与 **prompt** (qv) 中相同的格式序列；注意 \`%R' 的变量含义。 默认设置为 \`CORRECT>%R (y|n|e|a)? ' 在交互式 shells 中。

**promptchars (+)**

如果设置（为双字符字符串），**prompt** shell 变量中的 \`%#' 格式化序列将替换为普通用户的第一个字符和超级用户的第二个字符。

**pushdtohome (+)**

如果设置，不带参数的 _pushd_ 会执行 \`pushd ~', 如 _cd_ 。

**pushdsilent (+)**

如果设置， _pushd_ 和 _popd_ 不会打印目录堆栈。

**recexact (+)**

如果设置，即使可能有更长的匹配，也会在完全匹配时完成完成。

**recognize\_only\_executables (+)**

如果设置，命令列表仅显示路径中可执行的文件。慢的。

**rmstar (+)**

如果设置，则在执行 \`rm \*' 之前提示用户。

**rprompt (+)**

当提示显示在左侧时，要在屏幕右侧（输入命令后）打印的字符串。 它识别与 **prompt** 相同的格式字符。 它会在必要时自动消失并重新出现，以确保命令输入不会被遮挡，并且只有在提示符、命令输入和它本身在第一行适合时才会出现。 如果没有设置 **edit** ，则 **rprompt** 将在提示符之后和命令输入之前打印。

**savedirs (+)**

如果设置，shell 在退出前执行 \`dirs -S' 。 如果第一个单词设置为数字，则最多保存那么多目录堆栈条目。

**savehist**

如果设置，shell 会在退出前执行 \`history -S' 。 如果将第一个单词设置为数字，则最多保存多少行。 （数量应小于或等于 **history** 条目数量；如果设置为大于 **history** 设置的数量，则仅保存 **history** 条目） 如果第二个单词设置为 \`merge'，历史列表将与现有历史文件合并而不是替换它（如果有的话）并按时间戳排序并保留最近的事件。 如果 **savehist** 的第二个词是 \`merge' 并且第三个词设置为 \`lock', 历史文件更新将与可能希望同时合并历史的其他 shell 会话序列化。 (+)

**sched (+)**

_sched_ 内置命令打印预定事件的格式；如果没有给出，则使用 \`%h\\t%T\\t%R\\n' 。 格式序列在上面的 **prompt** 下进行了描述；注意 \`%R' 的变量含义。

**shell**

shell 所在的文件。这用于派生 shell 以解释设置了执行位但系统无法执行的文件。 （参见 **Builtin and non-builtin command execution**.) 初始化为 shell 的（与系统相关的）主目录。

**shlvl (+)**

嵌套壳的数量。 在登录 shell 中重置为 1。另请参见 **loginsh** 。

**status**

最后一个命令或反引号扩展或管道中的任何命令的退出状态都会传播到 **status** 。 （这也是默认的 **csh** 行为。） 此默认值与 POSIX 要求的不匹配（仅返回最后一个命令的状态）。 要匹配 POSIX 行为，您需要取消设置 **anyerror** 。

如果 **anyerror** 变量未设置，则管道的退出状态仅由管道中的最后一条命令确定，并且反引号扩展的退出状态 _不会_ 传播到 **status**。

如果命令异常终止，则将 0200 添加到状态。 失败的内置命令返回退出状态 \`1', 所有其他内置命令返回状态 \`0'。

**symlinks (+)**

可以设置为几个不同的值来控制符号链接 (\`symlink') 解析：

如果设置为 \`chase', 每当当前目录更改为包含符号链接的目录时，它都会扩展为链接指向的目录的真实名称。 这不适用于用户的主目录；这是一个错误。

如果设置为 \`ignore' ，shell 会尝试在链接被交叉之前构建一个相对于当前目录的当前目录。 这意味着 _cd_ing 通过符号链接然后 \`cd ..'ing 返回一个到原始目录。 这仅影响内置命令和文件名完成。

如果设置为 \`expand', shell 会尝试通过实际扩展看起来像路径名的参数来修复符号链接。 这会影响任何命令，而不仅仅是内置命令。 不幸的是，这不适用于难以识别的文件名，例如嵌入在命令选项中的文件名。 可以通过引用来防止扩展。 虽然此设置通常是最方便的，但当它无法识别应扩展的参数时，有时会产生误导，有时会令人困惑。 一个折衷方案是使用 \`ignore' 并在必要时使用编辑器命令 _normalize-path_ (默认绑定到 ^X-n) 。

一些例子是有序的。 首先，让我们设置一些播放目录：

\> cd /tmp-
\> mkdir from from/src to-
\> ln -s from/src to/dst

这是未设置 **symlinks** 的行为，

\> cd /tmp/to/dst; echo $cwd-
/tmp/to/dst-
\> cd ..; echo $cwd-
/tmp/from

这是 **symlinks** 设置为 \`chase' 的行为，

\> cd /tmp/to/dst; echo $cwd-
/tmp/from/src-
\> cd ..; echo $cwd-
/tmp/from

这是 **symlinks** 设置为 \`ignore' 的行为，

\> cd /tmp/to/dst; echo $cwd-
/tmp/to/dst-
\> cd ..; echo $cwd-
/tmp/to

这是 **symlinks** 设置为 \`expand' 的行为。

\> cd /tmp/to/dst; echo $cwd-
/tmp/to/dst-
\> cd ..; echo $cwd-
/tmp/to-
\> cd /tmp/to/dst; echo $cwd-
/tmp/to/dst-
\> cd ".."; echo $cwd-
/tmp/from-
\> /bin/echo ..-
/tmp/to-
\> /bin/echo ".."-
..

请注意， \`expand' 扩展 1) 就像 _cd_ 等内置命令的 \`ignore' 一样工作，2) 通过引用来防止，3) 在文件名传递给非内置命令之前发生。

**tcsh (+)**

shell 的版本号，格式为 \`R.VV.PP' ，其中 \`R' 是主要版本号， \`VV' 是当前版本， \`PP' 是补丁级别。

**term**

终端类型。 通常在 _~/.login_ 中设置，如 **启动和关闭** 中所述。

**time**

如果设置为一个数字，那么内置的 _time_ (qv) 在每个命令后自动执行，这需要超过那么多 CPU 秒数。 如果有第二个单词，则将其用作内置 _time_ 输出的格式字符串。 (u) 以下序列可用于格式字符串：

%U

进程在用户模式下花费的时间（以 cpu 秒为单位）。

%S

进程在内核模式下花费的时间（以 cpu 秒为单位）。

%E

以秒为单位的经过（挂钟）时间。

%P

CPU 百分比计算为 (%U + %S) / %E。

%W

进程被交换的次数。

%X

（共享）文本空间中使用的平均数量（以千字节为单位）。

%D

以千字节为单位的（非共享）数据/堆栈空间的平均使用量。

%K

已使用的总空间 (%X + %D) ，以千字节为单位。

%M

进程在任何时候使用的最大内存，以千字节为单位。

%F

主要页面错误的数量（需要从磁盘获取页面）。

%R

次要页面错误的数量。

%I

输入操作的数量。

%O

输出操作的数量。

%r

收到的套接字消息数。

%s

发送的套接字消息数。

%k

接收到的信号数。

%w

自愿上下文切换（等待）的数量。

%c

非自愿上下文切换的数量。

没有 BSD 资源限制功能的系统仅支持前四个序列。 对于支持资源使用报告的系统，默认时间格式为 \`%Uu %Ss %E %P %X+%Dk %I+%Oio %Fpf+%Ww' ，对于不支持资源使用报告的系统，默认时间格式为 \`%Uu %Ss %E %P' 。

在 Sequent 的 DYNIX/ptx 下， %X、 %D、 %K、 %r 和 %s 不可用，但以下附加序列是：

%Y

执行的系统调用数。

%Z

按需填零的页数。

%i

内核增加进程驻留集大小的次数。

%d

内核减少进程驻留集大小的次数。

%l

执行的读取系统调用的数量。

%m

执行的写入系统调用数。

%p

从原始磁盘设备读取的次数。

%q

对原始磁盘设备的写入次数。

默认时间格式为 \`%Uu %Ss %E %P %I+%Oio %Fpf+%Ww'。 请注意，多处理器上的 CPU 百分比可能高于 100%。

**tperiod (+)**

_periodic_ 性特殊别名执行之间的时间间隔（以分钟为单位）。

**tty (+)**

tty 的名称，如果没有附加到一个，则为空。

**uid (+)**

用户的真实用户 ID。

**user**

用户的登录名。

**verbose**

如果设置，则在历史替换（如果有）之后打印每个命令的单词。 由 **\-v** 命令行选项设置。

**version (+)**

版本 ID 戳。 它包含 shell 的版本号（参见 **tcsh**)、来源、发布日期、供应商、操作系统和机器（参见 **VENDOR**、 **OSTYPE** 和 **MACHTYPE**) 以及在编译时设置的以逗号分隔的选项列表。 注释在分发中默认设置的选项。

8b

shell 是8位干净的；默认

7b

shell 不是8位干净的

wide

shell 是干净的多字节编码（如 UTF-8）

nls

使用系统的 NLS；具有 NLS 的系统的默认设置

lf

登录 shell 在 _/etc/csh.cshrc_ 和 _~/.login_ 之前而不是在 _~/.tcshrc_ 和 _~/.history_ 之后执行 _/etc/csh.login_ 。

dl

为了安全， \`.' 放在 **path** 的最后;默认的

nd

\`.' 为安全起见，将从 **path** 中省略

vi

_vi_(1) 风格的编辑是默认的，而不是 _emacs_(1) 风格的

dtr

退出时登录外壳会丢弃 DTR

bye

_bye_ 是 _logout_ 的同义词， _log_ 是 _watchlog_ 的替代名称

al

启用 **autologout** ；默认

kan

根据区域设置在适当的情况下使用汉字，除非设置了 **nokanji** shell 变量

sm

使用系统的 _malloc_(3)

hb

执行 shell 脚本时模拟 \`#!<program> <args>' 约定

ng

_newgrp_ 内置可用

rh

shell 尝试设置 **REMOTEHOST** 环境变量

afs

如果本地身份验证失败，shell 会使用 kerberos 服务器验证您的密码。 **afsuser** shell 变量或 **AFSUSER** 环境变量会覆盖您的本地用户名（如果已设置）。

管理员可以输入额外的字符串来指示本地版本的差异。

**vimode (+)**

如果未设置，则各种键绑定将行为更改为更多 **emacs**(1) 样式：单词边界由 **wordchars** 与其他字符确定。

如果设置，各种键绑定将行为更改为更多 **vi**(1) 样式：单词边界由 **wordchars** 与空白与其他字符确定；游标行为取决于当前的 vi 模式（命令、删除、插入、替换）。

此变量由 _bindkey_ **\-e** 取消设置并由 _bindkey_ **\-v** 设置。 如果需要，用户可以在这些 _bindkey_ 操作之后显式地设置或取消 **vimode** 。

**visiblebell (+)**

如果设置，将使用屏幕闪烁而不是铃声。另请参阅 **nobeep**。

**watch (+)**

用于监视登录和注销的用户/终端对列表。 如果任一用户是 \`any' ，则所有终端都会为给定用户监视，反之亦然。 将 **watch** 设置为 \`(any any)' 会监视所有用户和终端。 例如，

set watch = (george ttyd1 any console $user any)

报告 ttyd1 上的用户 \`george' 、控制台上的任何用户以及任何终端上的自己（或侵入者）的活动。

默认情况下，每 10 分钟检查一次登录和注销，但可以将 **watch** 的第一个单词设置为每隔这么多分钟检查一次的数字。 例如，

set watch = (1 any any)

每分钟报告一次任何登录/注销。 对于不耐烦的人， _log_ 内置命令随时触发 **watch** 报告。 首次设置 **watch** 时，会报告所有当前登录（与内置 _log_ 日志一样）。

**who** 变量控制 **watch** 报告的格式。

**who (+)**

**watch** 消息的格式字符串。 以下序列由给定信息替换：

%n

登录/注销的用户名。

%a

观察到的操作，即 \`logged on'、 \`logged off' 或 \`replaced _olduser_ on'。

%l

用户登录/注销的终端 (tty)。

%M

远程主机的完整主机名，如果登录/注销来自本地主机，则为 \`local' 。

%m

远程主机的主机名，直到第一个 \`.'。 如果是 IP 地址或 X Window 系统显示，则会打印全名。

%M 和 %m 仅在将远程主机名存储在 _/etc/utmp_ 中的系统上可用。 如果未设置，则使用 \`%n has %a %l from %m.' ，，或者在没有存储远程主机名的系统上使用 \`%n has %a %l.' 。

**wordchars (+)**

由 _forward-word_、 _backward-word_ 等编辑器命令视为单词一部分的非字母数字字符列表。 如果未设置，则根据 **vimode** 的状态确定默认值：如果未设置 **vimode** ，则使用 \`\*?\_-.\[\]~=' 作为默认值；如果设置了 **vimode** ，则使用 \`\_' 作为默认值。

[环境](#__u73AF___u5883_)
=======================

**AFSUSER (+)**

等效于 **afsuser** shell 变量。

**COLUMNS**

终端中的列数。 请参阅 **阅终端管理**。

**DISPLAY**

由 X 窗口系统使用（请参阅 _X_(1))。 如果设置，shell 不会设置 **autologout** (qv)。

**EDITOR**

默认编辑器的路径名。 如果未设置 **editors** shell 变量，则由 _run-fg-editor_ 命令使用。 另请参见 **VISUAL** 环境变量。

**GROUP (+)**

等效于 **group** shell 变量。

**HOME**

等效于 **home** shell 变量。

**HOST (+)**

初始化为运行 shell 的机器的名称，由 _gethostname_(2) 系统调用确定。

**HOSTTYPE (+)**

初始化为运行 shell 的机器类型，在编译时确定。 此变量已过时，将在未来版本中删除。

**HPATH (+)**

_run-help_ 编辑器命令在其中查找命令文档的以冒号分隔的目录列表。 朗

**LANG**

提供首选的字符环境。 请参阅 **本机语言系统支持**。

**LC\_CTYPE**

如果设置，则仅更改 ctype 字符处理。 请参阅 **本机语言系统支持**。

**LINES**

终端中的行数。 请参阅 **终端管理**.

**LS\_COLORS**

这个变量的格式让人想起 **termcap(5)** 文件格式；以冒号分隔的 "_xx=string_" 形式的表达式列表，其中 "_xx_" 是两个字符的变量名。 具有相关默认值的变量是：

no 0

普通（非文件名）文本

fi 0

常规文件

di 01;34

目录

ln 01;36

符号链接

pi 33

命名管道 (FIFO)

so 01;35

嵌套字

do 01;35

门

bd 01;33

块设备

cd 01;32

字符设备

ex 01;32

可执行文件

mi (none)

缺少文件（默认为 fi)

or (none)

孤立的符号链接（默认为 ln)

lc ^\[\[

左码

rc m

右码

ec (none)

结束代码（替换 lc+no+rc)

您只需要包含要更改默认值的变量。

文件名也可以根据文件扩展名着色。 这在 **LS\_COLORS** 变量中使用语法 **"\*ext=string"** 指定。 例如，使用 ISO 6429 代码，将所有 C 语言源文件着色为蓝色，您可以指定 **"\*.c=34"** 。 这会将所有以 **.c** 结尾的文件着色为蓝色 (34)。

控制字符可以用 C 风格的转义表示法或类似 stty 的 ^ 表示法编写。C 风格的符号为 Escape 添加了 **^\[** ，为正常的空格字符添加了 **\_** ，以及 **?** 删除。 此外， **^\[** 转义字符可用于覆盖 **^\[**、 **^**、 **:** 和 **\=**。

每个文件将被写为 **<lc>** **<color-code>** **<rc>** **<filename>** **<ec>**。如果 **<ec>** 代码未定义，则将使用序列 **<lc>** **<no>** **<rc>** 代替。 这通常使用起来更方便，但不太通用。 提供了左、右、尾代码，让您不必一遍又一遍地键入常用部分并支持奇怪的终端；您通常根本不需要更改它们，除非您的终端不使用 ISO 6429 颜色序列而是使用不同的系统。

如果您的终端确实使用 ISO 6429 颜色代码，您可以用分号分隔的数字命令组成类型代码（即，除了 **lc**、 **rc** 和 **ec** 代码之外的所有代码）。最常见的命令是：

0

恢复默认颜色

1

更亮的颜色

4

对于带下划线的文本

5

用于闪烁文本

30

用于黑色前景

31

用于红色前景

32

用于绿色前景

33

黄色（或棕色）前景

34

用于蓝色前景

35

用于紫色前景

36

用于青色前景

37

用于白色（或灰色）前景

40

黑色背景

41

红色背景

42

绿色背景

43

黄色（或棕色）背景

44

蓝色背景

45

紫色背景

46

青色背景

47

白色（或灰色）背景

并非所有命令都适用于所有系统或显示设备。

一些终端程序无法正确识别默认结束代码。 如果在列出目录后所有文本都被着色，请尝试将 **no** 和 **fi** 代码从 0 更改为标准前景色和背景色的数字代码。

**MACHTYPE (+)**

在编译时确定的机器类型（微处理器类或机器模型）。

**NOREBIND (+)**

如果设置，可打印字符不会反弹到 _self-insert-command_。 请参阅 **本机语言系统支持**。

**OSTYPE (+)**

操作系统，在编译时确定。

**PATH**

在其中查找可执行文件的以冒号分隔的目录列表。 等效于 **path** shell 变量，但格式不同。

**PWD (+)**

等效于 **cwd** shell 变量，但不与之同步；仅在实际目录更改后更新。

**REMOTEHOST (+)**

用户远程登录的主机，如果是这种情况并且 shell 能够确定它。 仅当 shell 如此编译时才设置；查看 **version** shell 变量。

**SHLVL (+)**

等效于 **shlvl** shell 变量。

**SYSTYPE (+)**

当前系统类型。 （仅限Domain/OS)

**TERM**

等效于 **term** shell 变量。

**TERMCAP**

终端能力字符串。 请参阅 **终端管理**。

**USER**

等效于 **user** shell 变量。

**VENDOR (+)**

vendor, 在编译时确定。

**VISUAL**

默认全屏编辑器的路径名。 如果未设置 **editors** shell 变量，则由 _run-fg-editor_ 命令使用。 另请参阅 **EDITOR** 环境变量。

[文件](#__u6587___u4EF6_)
=======================

_/etc/csh.cshrc_

每个 shell 都先阅读。 ConvexOS、 Stellix 和 Intel 使用 _/etc/cshrc_ ，而 NeXTs 使用 _/etc/cshrc.std_。 A/UX、 AMIX、 Cray 和 IRIX 在 _csh_(1) 中没有等价物，但无论如何都要在 _tcsh_ 中读取这个文件。 Solaris 2.x 也没有，但 _tcsh_ 读取 _/etc/.cshrc_。 (+)

_/etc/csh.login_

在 _/etc/csh.cshrc_ 之后由登录 shell 读取。 ConvexOS、 Stellix 和 Intel 使用 _/etc/login_, NeXTs 使用 _/etc/login.std_, Solaris 2.x 使用 _/etc/.login_ 和 A/UX、 AMIX、 Cray 和 IRIX 使用 _/etc/cshrc_。

_~/.tcshrc (+)_

由 _/etc/csh.cshrc_ 或其等效项之后的每个 shell 读取。

_~/.cshrc_

如果 _~/.tcshrc_ 不存在，则由每个 shell 读取，在 _/etc/csh.cshrc_ 或其等效项之后。本手册使用 \`_~/.tcshrc_' 表示 \`_~/.tcshrc_ ，或者，如果找不到 _~/.tcshrc_ ，则表示 _~/.cshrc_'。

_~/.history_

如果设置了 **savehist** ，则在 _~/.tcshrc_ 之后由登录 shell 读取，但另请参阅 **histfile**。

_~/.login_

在 _~/.tcshrc_ 或 _~/.history_ 之后由登录 shell 读取。 shell 可以编译为在 _~/.login_ 之前而不是 _~/.tcshrc_ 和 _~/.history_ 之后读取；查看 **version** shell 变量。

_~/.cshdirs (+)_

如果设置了 **savedirs** ，则在 _~/.login_ 之后由登录 shell 读取，但另请参阅 **dirsfile**。

_/etc/csh.logout_

在注销时由登录 shell 读取。 ConvexOS、Stellix 和 Intel 使用 _/etc/logout_ 而 NeXTs 使用 _/etc/logout.std_。 A/UX、 AMIX、 Cray 和 IRIX 在 _csh_(1) 中没有等价物，但无论如何都要在 _tcsh_ 中读取这个文件。 Solaris 2.x 也没有，但 _tcsh_ 读取 _/etc/.logout_。 (+)

_~/.logout_

在 _/etc/csh.logout_ 或其等效项之后由登录 shell 读取。

_/bin/sh_

用于解释不以 \`#' 开头的 shell 脚本。

_/tmp/sh\*_

\`<<' 的临时文件。

_/etc/passwd_

\`~name' 替换的主目录的来源。

如果 shell 是这样编译的，那么读取启动文件的顺序可能会有所不同；请参阅 **启动和关闭** 和 **version** shell 变量。

[新功能 (+)](#__u65B0___u529F___u80FD__(+))
========================================

本手册将 _tcsh_ 描述为一个单独的实体，但有经验的 _csh_(1) 用户会希望特别注意 _tcsh_ 的新功能。

命令行编辑器，支持 _emacs_(1) 样式或 _vi_(1) 样式的键绑定。 请参阅 **命令行编辑器** 和 **编辑器命令**。

可编程的交互式单词完成和列表。 请参阅 **完成和列出** and the _complete_ 和 _uncomplete_ 的内置命令。

文件名、命令和变量的 **拼写更正** (qv)。

**编辑器命令** (qv) 在键入命令的中间执行其他有用的功能，包括文档查找 (_run-help_)、快速编辑器重新启动 (_run-fg-editor_) 和命令解析 (_which-command_)。

增强的历史记录机制。 历史列表中的事件带有时间戳。 另请参阅 _history_ 命令及其相关的 shell 变量、以前未记录的 \`#' 事件说明符和 **历史替换**下的新修饰符、 _\*-history_、 _history-search-\*_、 _i-search-\*_、 _vi-search-\*_ 和 _toggle-literal-history_ 编辑器命令和 **histlit** shell 变量。

增强的目录解析和目录堆栈处理。 请参阅 _cd_、 _pushd_、 _popd_ 和 _dirs_ 命令及其关联的 shell 变量、 **目录堆栈替换** 的描述、 **dirstack**、 **owd** 和 **symlinks** shell 变量以及 _normalize-command_ 和 _normalize-path_ 编辑器命令。

全局模式中的否定。请参阅 **文件名替换**。

新的 **文件查询运算符** (qv) 和使用它们的内置 _filetest_ 。

各种 **自动、定期和定时事件** (qv)，包括预定事件、特殊别名、自动注销和终端锁定、命令定时以及监视登录和注销。

支持本机语言系统（请参阅 **本机语言系统支持**)、操作系统变体功能（请参阅 **操作系统变体支持** 和 **echo\_style** 变量）和系统相关文件位置（请参阅 **文件**)。

丰富的终端管理能力。 请参阅 **终端管理**。

新的内置命令，包括 _builtins_、 _hup_、 _ls-F_、 _newgrp_、 _printenv_、 _which_ 和 _where_ (qv)。

使 shell 可以轻松获得有用信息的新变量。 请参阅 **gid**、 **loginsh**、 **oid**、 **shlvl**、 **tcsh**、 **tty**、 **uid** 和 **version** shell 变量以及 **HOST**、 **REMOTEHOST**、 **VENDOR**、 **OSTYPE** 和 **MACHTYPE** 环境变量。

用于在提示字符串中包含有用信息的新语法（请参阅 **prompt**)，以及用于循环和拼写更正的特殊提示（请参阅 **prompt2** 和 **prompt3**)。

只读变量。 请参阅**变量替换**。

[缺陷](#__u7F3A___u9677_)
=======================

当挂起的命令重新启动时，如果它与当前目录不同，shell 将打印它启动的目录。 这可能会产生误导（即错误），因为作业可能在内部更改了目录。

Shell 内置函数不可停止/不可重启。当试图停止时， \`a ; b ; c' 形式的命令序列也不会被优雅地处理。如果你暂停 \`b'，shell 将立即执行 \`c' 。 如果此扩展是由 _alias_. 引起的，则这一点尤其明显。 将命令序列放在 () 中就足够了，以强制它进入子 shell，即 \`( a ; b ; c )'。

进程启动后对 tty 输出的控制是原始的；也许这会激发人们在一个好的虚拟终端界面上工作。 在虚拟终端界面中，可以通过输出控制完成更多有趣的事情。

别名替换最常用于笨拙地模拟 shell 程序。应该提供 shell 程序而不是别名。

控制结构应该被解析而不是被识别为内置命令。 这将允许将控制命令放置在任何地方，与 \`|' 组合，并与 \`&' 和 \`;' 一起使用元语法。

_foreach_ 在查找其 _end_ 时不会忽略此处的文档。

应该可以在命令替换的输出上使用 \`:' 修饰符。

如果终端不能向上移动光标（即终端类型 \`dumb')，那么长于屏幕宽度的行的屏幕更新非常差。

**HPATH** 和 **NOREBIND** 不需要是环境变量。

不使用 \`?'、 \`\*' 或 \`\[\]' 或使用 \`{}' 或 \`~' 的全局模式不会被正确否定。

_if_ 的单命令形式即使表达式为假且命令未执行，也会输出重定向。

_ls-F_ 在对文件名进行排序时包含文件标识字符，并且不能很好地处理文件名中的控制字符。它不能被打断。

命令替换支持多个命令和条件，但不支持循环或反向 _goto_。

在 https://bugs.astron.com/ 报告错误，最好有修复。 如果您想帮助维护和测试 tcsh，请将您自己添加到 https://mailman.astron.com/ 的邮件列表中。

[TCSH 中的 T](#TCSH___u4E2D___u7684__T)
=====================================

1964 年，DEC 生产了 PDP-6。 PDP-10 是后来的重新实施。 1970 年左右，当 DEC 推出第二款型号 KI10 时，它被重新命名为 DECsystem-10。

TENEX 于 1972 年在 Bolt, Beranek & Newman（马萨诸塞州剑桥的一家智库）创建，作为按需分页虚拟内存操作系统的实验。 他们为 DEC PDP-10 构建了一个新的寻呼机，并创建了与之配套的操作系统。 它在学术界非常成功。

1975年，DEC推出了PDP-10的新型号KL10；他们打算只为新盒子提供他们从 BBN 获得许可的 TENEX 版本。 他们称他们的版本为 TOPS-20（他们的大写已注册商标）。 很多 TOPS-10 用户（ “PDP-10 的操作系统”）反对；因此，DEC 发现自己在同一硬件上支持两个不兼容的系统——但 PDP-11 上却有 6 个！

TENEX 和 TOPS-20 到版本 3，通过称为 ULTCMD 的用户代码级子例程库完成命令。 在版本 3 中，DEC 将所有这些功能和更多功能移到了监视器（Unix 类型的 (\`kernel' ），由 COMND% JSYS 访问（\`Jump to SYStem' 指令，主管调用机制 \[are my IBM roots also showing?\])。

tcsh 的创建者对该功能以及 TENEX 和 TOPS-20 的其他几个功能印象深刻，并创建了一个模仿它们的 csh 版本。

[限制](#__u9650___u5236_)
=======================

系统将参数列表限制为 ARG\_MAX 个字符。

涉及文件名扩展的命令的参数数量限制为参数列表中允许的字符数的 1/6。

命令替换可以替换的字符不能超过参数列表中允许的字符。

为了检测循环，shell 将单行中的 _alias_ 替换次数限制为 20。

[参见](#__u53C2___u89C1_)
=======================

csh(1), emacs(1), ls(1), newgrp(1), sh(1), setpath(1), stty(1), su(1), tset(1), vi(1), x(1), access(2), execve(2), fork(2), killpg(2), pipe(2), setrlimit(2), sigvec(2), stat(2), umask(2), vfork(2), wait(2), malloc(3), setlocale(3), tty(4), a.out(5), termcap(5), environ(7), termio(7), 介绍 C Shell

[版本](#__u7248___u672C_)
=======================

本手册记录了 tcsh 6.21.00 (Astron) 2019-05-08。

[作者](#__u4F5C___u8005_)
=======================

William Joy

_csh_(1) 的原作者

J.E. Kulp, IIASA, Laxenburg, Austria

作业控制和目录堆栈功能

Ken Greer, HP Labs, 1981

文件名完成

Mike Ellis, Fairchild, 1983

命令名称识别/完成

Paul Placeway, Ohio State CIS Dept., 1983-1993

命令行编辑器、提示例程、新的 glob 语法以及大量修复和加速

Karl Kleinpaste, CCI 1983-4

特殊别名、目录堆栈提取内容、登录/注销监视、预定事件以及新提示格式的想法

Rayan Zachariassen, University of Toronto, 1984

_ls-F_ 和内置 _which_ 和许多错误修复、修改和加速

Chris Kingsley, Caltech

快速存储分配器例程

Chris Grevstad, TRW, 1987

将 4.3BSD _csh_ 并入 _tcsh_

Christos S. Zoulas, Cornell U. EE Dept., 1987-94

HPUX、 SVR2 和 SVR3 的 Ports, getwd.c 的 SysV 版本、SHORT\_STRINGS 支持和 sh.glob.c 的新版本

James J Dempsey, BBN, 和 Paul Placeway, OSU, 1988

A/UX port

Daniel Long, NNSC, 1988

**wordchars**

Patrick Wolfe, Kuck and Associates, Inc., 1988

_vi_ 模式清理

David C Lawrence, Rensselaer Polytechnic Institute, 1989

**autolist** 和模棱两可的完成列表

Alec Wolman, DEC, 1989

提示中的换行符

Matt Landau, BBN, 1989

_~/.tcshrc_

Ray Moody, Purdue Physics, 1989

魔法空格键历史扩展

Mordechai ????, Intel, 1989

printprompt() 修复和添加

Kazuhiro Honda, Dept. of Computer Science, Keio University, 1989

自动拼写更正和 **prompt3**

Per Hedeland, Ellemtel, Sweden, 1990-

各种错误修正、改进和手动更新

Hans J. Albertsson (Sun Sweden)

**ampm**、 _settc_ 和 _telltc_

Michael Bloom

中断处理修复

Michael Fine, Digital Equipment Corp

扩展密钥支持

Eric Schnoebelen, Convex, 1990

Convex 支持，大量 _csh_ 错误修复，目录堆栈的保存和恢复

Ron Flax, Apple, 1990

A/UX 2.0 （重新）移植

Dan Oscarsson, LTH Sweden, 1990

对非 NLS 站点的 NLS 支持和模拟 NLS 支持，修复

Johan Widen, SICS Sweden, 1990

**shlvl**, Mach 支持, _correct-line_, 8位打印

Matt Day, Sanyo Icon, 1990

POSIX termio 支持，, SysV 限制修复

Jaap Vermeulen, Sequent, 1990-91

Vi 模式修复、扩展行、窗口更改修复、对称端口

Martin Boyer, Institut de recherche d'Hydro-Quebec, 1991

**autolist** beeping 选项，修改历史搜索以搜索从行首到光标的整个字符串。

Scott Krotz, Motorola, 1991

Minix port

David Dawes, Sydney U. Australia, Physics Dept., 1991

SVR4 作业控制修复

Jose Sousa, Interactive Systems Corp., 1991

扩展的 _vi_ 修复和 _vi_ 删除命令

Marc Horowitz, MIT, 1991

ANSIfication 修复，新的 exec 哈希代码，imake 修复， _where_

Bruce Sterling Woodcock, sterling@netcom.com, 1991-1995

ETA 和 Pyramid port, Makefile 和 lint 修复, **ignoreeof**\=n addition, 和 各种其他可移植性更改和错误修复

Jeff Fink, 1992

_complete-word-fwd_ 和 _complete-word-back_

Harry C. Pulley, 1992

Coherent port

Andy Phillips, Mullard Space Science Lab U.K., 1992

VMS-POSIX port

Beto Appleton, IBM Corp., 1992

Walking process group 修复, _csh_ 错误修复, POSIX 文件测试, POSIX SIGHUP

Scott Bolte, Cray Computer Corp., 1992

CSOS port

Kaveh R. Ghazi, Rutgers University, 1992

Tek, m88k, Titan and Masscomp 端口和修复。添加了自动配置支持。

Mark Linderman, Cornell University, 1992

OS/2 port

Mika Liljeberg, liljeber@kruuna.Helsinki.FI, 1992

Linux port

Tim P. Starrin, NASA Langley Research Center Operations, 1993

Read-only 变量

Dave Schweisguth, Yale University, 1993-4

新的手册页和 tcsh.man2html

Larry Schwimmer, Stanford University, 1993

AFS 和 HESIOD 补丁

Luke Mewburn, RMIT University, 1994-6

在提示符中增强了目录打印，添加 **ellipsis** 和 **rprompt**。

Edward Hutchins, Silicon Graphics Inc., 1996

添加隐式 cd。

Martin Kraemer, 1997

移植到西门子 Nixdorf EBCDIC 机器

Amol Deshpande, Microsoft, 1997

移植到 WIN32（Windows/95 和 Windows/NT）；编写了所有缺少的库和消息目录代码以连接到 Windows。

Taga Nayuta, 1998

颜色 ls 添加。

[致谢](#__u81F4___u8C22_)
=======================

Bryan Dunlap, Clayton Elwell, Karl Kleinpaste, Bob Manson, Steve Romig, Diana Smetters, Bob Sutterfield, Mark Verber, Elizabeth Zwicky 和俄亥俄州立大学的所有其他人寻求建议和鼓励

网络上所有的人，为了忍受，报告错误，并建议每个版本的新添加

Richard M. Alderson III, 写了 \`T in tcsh' 部分

8 May 2019

Astron 6.21.00