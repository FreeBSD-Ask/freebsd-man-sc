  ENV(1)  

ENV(1)

FreeBSD General Commands Manual

ENV(1)

[名称](#__u540D___u79F0_)
=======================

`env` —

设置环境并执行命令，或打印环境

[概要](#__u6982___u8981_)
=======================

`env` \[`-0iv`\] \[`-L`|`-U` user\[/class\]\] \[`-u` name\] \[name\=value ...\] `env` \[`-iv`\] \[`-L`|`-U` user\[/class\]\] \[`-P` altpath\] \[`-S` string\] \[`-u` name\] \[name\=value ...\] utility \[argument ...\]

[描述](#__u63CF___u8FF0_)
=======================

`env` 实用程序在修改命令行中指定的环境后执行另一个 utility 。 每个 name\=value 选项指定环境变量 name 的设置，其值为 value 。 所有这些环境变量都是在 utility 执行之前设置的。

选项如下：

[`-0`](#0)

以 NUL 结束每个输出行，而不是换行符。

[`-i`](#i)

仅使用 name\=value 选项指定的那些环境变量执行该 utility 。 `env` 继承的环境被完全忽略。

[`-L`](#L) | [`-U`](#U) user\[/class\]

在处理任何 `-i` 或 `-u` 选项之后，但在处理任何 name\=value 选项之前，将指定用户和登录类的 login.conf(5) 中的环境变量定义添加到环境中。 如果使用 `-L` ，则只读取系统范围的 /etc/login.conf.db 文件；如果使用 `-U` ，则指定用户的 ~/.login\_conf 也会被读取。 用户可以由名称或 uid 指定。如果给出了用户名 ‘`-`’ ，则不会进行用户查找，如果没有明确给出，登录类将默认为 ‘`default`’ ，并且不会对值进行替换。

[`-P`](#P) altpath

搜索由 altpath 指定的目录集以定位指定的 utility ，而不是使用 `PATH` 环境变量的值。

[`-S`](#S) string

将给定的 string 拆分为多个字符串，并将每个结果字符串作为 `env` 实用程序的单独参数进行处理。 `-S` 选项识别一些特殊的字符转义序列并且还支持环境变量替换，如下所述。

[`-u`](#u) name

如果环境变量 name 在环境中，则在处理其余选项之前将其删除。 这类似于 sh(1) 中的 `unset` 命令。 name 的值不能包含 ‘`=`’ 字符。

[`-v`](#v)

打印 `env` 实用程序完成的每个处理步骤的详细信息。 如果多次指定 `-v` ，将打印附加信息。

仅当在任何 name\=value 选项之前指定上述选项时，它们才会被识别。

如果未指定 utility ，则 `env` 会打印出环境中变量的名称和值。 除非指定了 `-0` 否则每个名称/值对由新行分隔，在这种情况下，名称/值对由 NUL 分隔。 `-0` 和 utility 不能一起指定。

[\-S （拆分字符串）处理的详细信息](#-S___uFF08___u62C6___u5206___u5B57___u7B26___u4E32___uFF09___u5904___u7406___u7684___u8BE6___u7EC6___u4FE1___u606F_)
------------------------------------------------------------------------------------------------------------------------------------------

`-S` 选项的处理将根据在 string 中找到的任何空格或 <tab> 字符将给定 string 拆分为单独的参数。 然后，这些新参数中的每一个都将被视为已在原始 `env` 命令中指定为单独的参数。

空格和制表符可以通过使用单引号 (“`'`”) 或双引号 (‘`"`’)-
或反斜杠 (‘`\`’) 嵌入其中一个新参数中。 单引号将转义所有非单引号字符，直到匹配的单引号。 双引号将转义所有非双引号字符，直到匹配的双引号。 如果在匹配的引号字符之前到达 string 的结尾，则这是一个错误。

如果 `-S` 将创建一个以 ‘`#`’ 字符开头的新参数，则该参数和 string 的其余部分将被忽略。 当您希望新参数以 ‘`#`’ 字符开头时，可以使用 ‘`\#`’ 序列，而不会导致 string 的其余部分被跳过。

在处理 string 值时， `-S` 处理会将某些字符组合视为转义序列，表示要采取的某些操作。 字符转义序列采用反斜杠表示法。 字符及其含义如下：

[`\c`](#_ec)

忽略 string 中的剩余字符。 这不能出现在双引号字符串中。

[`\f`](#_ef)

替换为 <form-feed> 字符。

[`\n`](#_en)

替换为 <new-line> 字符。

[`\r`](#_er)

替换为 <回车> 字符。

[`\t`](#_et)

替换为 <tab> 字符。

[`\v`](#_ev)

替换为 <vertical tab> 字符。

[`\#`](#_e_)

替换为 ‘`#`’ 字符。 当您需要一个 ‘`#`’ 作为通过拆分给定 string 创建的一个参数中的第一个字符时，这将很有用。

[`\$`](#_e$)

替换为 ‘`$`’ 字符。

[`\_`](#_e__2)

如果在双引号字符串中找到它，则将其替换为单个空格。 如果在带引号的字符串之外找到它，则将其视为原始 string 中新参数之间的分隔符。

[`\"`](#_e__3)

替换为 <双引号> 字符。

[`\´`](#_e_')

替换为 <单引号> 字符。

[`\\`](#_e_e)

替换为反斜杠字符。

<single-quote> 和反斜杠的序列是唯一在单引号字符串中被识别的序列。 其他序列在单引号字符串中没有特殊含义。 所有转义序列都在双引号字符串中被识别。 如果单个 ‘`\`’ 字符后跟上面列出的字符以外的字符，则会出错。

`-S` 的处理还支持从环境变量中替换值。 为此，环境变量的名称必须在 ‘`${}`’ 之内，例如： `${SOMEVAR}` 。 不支持 `$SOMEVAR` 的通用 shell 语法。 所有替换的值都将是环境变量的值，就像最初调用 `env` 实用程序时一样。 如上所述，不会检查这些值是否有任何转义序列。 并且 name\=value 的任何设置都不会影响 `-S` 处理中用于替换的值。

此外， `-S` 处理不能引用大多数 shell 定义的特殊参数的值。 例如， `-S` 无法识别特殊参数，例如： ‘`$*`’, ‘`$@`’, ‘`$#`’, ‘`$?`’ 或 ‘`$$`’ 如果它们出现在给定的 string 中。

[在 shell 脚本中使用](#__u5728__shell___u811A___u672C___u4E2D___u4F7F___u7528_)
-------------------------------------------------------------------------

`env` 实用程序通常用作解释脚本的第一行的 interpreter ，如 execve(2) 中所述。

请注意内核解析 ‘`#!`’ 的方式 自 FreeBSD 6.0 起，解释脚本的（第一行）已更改。 在此之前， FreeBSD 内核会根据在该行中找到的任何空格（空格或 <tab> 字符）将该第一行拆分为单独的参数。 所以，如果一个名为 /usr/local/bin/someport 的脚本的第一行是：

`#!/usr/local/bin/php -n -q -dsafe_mode=0`

那么 /usr/local/bin/php 程序将使用以下参数启动：

arg\[0\] = '/usr/local/bin/php' arg\[1\] = '-n' arg\[2\] = '-q' arg\[3\] = '-dsafe\_mode=0' arg\[4\] = '/usr/local/bin/someport' 

加上用户在执行 someport 时指定的任何参数。 但是，这个处理多个选项就 ‘`#!`’ 行不是任何其他操作系统解析解释脚本的第一行的方式。 因此，在对 FreeBSD 6.0 进行更改后，该脚本将导致 /usr/local/bin/php 以以下参数启动：

arg\[0\] = '/usr/local/bin/php' arg\[1\] = '-n -q -dsafe\_mode=0' arg\[2\] = '/usr/local/bin/someport' 

加上用户指定的任何参数。 这导致一些脚本的行为发生了重大变化。 在上述脚本的情况下，要让它在 FreeBSD 6.0 下的行为方式与在早期版本下的行为方式相同，第一行应更改为：

`#!/usr/bin/env -S /usr/local/bin/php -n -q -dsafe_mode=0`

`env` 实用程序将以整行作为单个参数启动：

`arg[1] = '-S /usr/local/bin/php -n -q -dsafe_mode=0'`

然后 `-S` 处理将在执行 /usr/local/bin/php 之前将该行拆分为单独的参数。

[环境](#__u73AF___u5883_)
=======================

如果名称不包含 ‘`/`’ 字符，则 `env` 实用程序使用 `PATH` 环境变量来定位请求的 utility ，除非已指定 `-P` 选项。

[退出状态](#__u9000___u51FA___u72B6___u6001_)
=========================================

The `env` utility exits 0 on success, and >0 if an error occurs. 退出状态 126 表示已找到 utility ，但无法执行。 退出状态 127 表示找不到 utility 。

[实例](#__u5B9E___u4F8B_)
=======================

由于 `env` 实用程序通常用作解释脚本的第一行的一部分，因此以下示例显示了 `env` 实用程序在脚本中的多种用途。

解释脚本的内核处理不允许脚本直接引用其他脚本作为它自己的解释器。 作为一种解决方法，主要区别在于

`#!/usr/local/bin/foo`

和

`#!/usr/bin/env /usr/local/bin/foo`

是即使 /usr/local/bin/foo 本身就是一个解释脚本，后者也可以工作。

可能 `env` 最常见的用途是为脚本找到正确的解释器，此时解释器可能位于不同系统的不同目录中。 以下示例将通过搜索 `PATH` 指定的目录来找到 ‘`perl`’ 解释器。

`#!/usr/bin/env perl`

该示例的一个限制是它假定用户的 `PATH` 值设置为一个可以找到您要执行的解释器的值。 `-P` 选项可用于确保在搜索 utility 时使用特定的目录列表。 请注意，此示例还需要 `-S` 选项才能正常工作。

`#!/usr/bin/env -S -P/usr/local/bin:/usr/bin perl`

仅当它位于 /usr/local/bin 或 /usr/bin 中时，上面才会找到 ‘`perl`’ 。 这可以与 `PATH` 的当前值相结合，以提供更大的灵活性。 请注意， `-S` 和 `-P` 选项之间不需要空格：

`#!/usr/bin/env -S-P/usr/local/bin:/usr/bin:${PATH} perl`

[兼容性](#__u517C___u5BB9___u6027_)
================================

`env` 实用程序接受 `-` 选项作为 `-i` 的同义词。

[参见](#__u53C2___u89C1_)
=======================

printenv(1), sh(1), execvp(3), login.conf(5), environ(7)

[标准](#__u6807___u51C6_)
=======================

`env` 实用程序符合 IEEE Std 1003.1-2001 (“POSIX.1”) 。 `-0`, `-L`, `-P`, `-S`, `-U`, `-u` 和 `-v` 选项是 FreeBSD 支持的非标准扩展，但在其他操作系统上可能不可用。

[历史](#__u5386___u53F2_)
=======================

`env` 命令出现在 4.4BSD 中。 FreeBSD 6.0 中添加了 `-P`, `-S` 和 `-v` 选项。 FreeBSD 13.0 中添加了 `-0`, `-L` 和 `-U` 选项。

[缺陷](#__u7F3A___u9677_)
=======================

出于显而易见的原因， `env` 实用程序不处理名称中带有等号 (‘`=`’) 的 utility 值。

`env` 实用程序在处理 `-S` 选项时不考虑多字节字符，这可能会导致某些语言环境中的结果不正确。

March 3, 2021

FreeBSD 13.1-RELEASE