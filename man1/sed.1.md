  SED(1)  

SED(1)

FreeBSD General Commands Manual

SED(1)

[名称](#__u540D___u79F0_)
=======================

`sed` —

流编辑器

[概要](#__u6982___u8981_)
=======================

`sed` \[`-Ealnru`\] command \[`-I` extension\] \[`-i` extension\] \[file ...\] `sed` \[`-Ealnru`\] \[`-e` command\] \[`-f` command\_file\] \[`-I` extension\] \[`-i` extension\] \[file ...\]

[描述](#__u63CF___u8FF0_)
=======================

`sed` 实用程序读取指定的文件，如果没有指定文件，则读取标准输入，根据命令列表修改输入。 然后将输入写入标准输出。

可以将单个命令指定为 `sed` 的第一个参数。 可以使用 `-e` 或 `-f` 选项指定多个命令。 所有命令都按照指定的顺序应用于输入，无论其来源如何。

可以使用以下选项：

[`-E`](#E)

将正则表达式解释为扩展（现代）正则表达式，而不是基本正则表达式（BRE）。 re\_format(7) 手册页完整地描述了这两种格式。

[`-a`](#a)

默认情况下，作为 “w” 函数的参数列出的文件在任何处理开始之前创建（或截断）。 `-a` 选项导致 `sed` 延迟打开每个文件，直到包含相关 “w” 函数的命令应用于输入行。

[`-e`](#e) command

将 command 参数指定的编辑命令附加到命令列表中。

[`-f`](#f) command\_file

将文件 command\_file 中的编辑命令附加到命令列表中。 每个编辑命令都应列在单独的行上。 如果 command\_file 为 “`-`” ，则从标准输入读取命令。

[`-I`](#I) extension

就地编辑文件，以指定的 extension 保存备份。 如果给出零长度 extension ，则不会保存备份。 不建议在就地编辑文件时提供零长度 extension ，因为在磁盘空间耗尽等情况下，您可能会面临损坏或部分内容的风险。

请注意，使用 `-I` 进行就地编辑仍会在覆盖所有文件的单个连续行地址空间中进行，尽管每个文件都保留其个性，而不是形成一个输出流。 文件之间的行计数器永远不会重置，地址范围可以跨越文件边界，并且 “$” 地址仅匹配最后一个文件的最后一行。 （参见 [Sed 地址 。](#Sed___u5730___u5740____u3002_)) 在许多需要使用 `-i` 的就地编辑情况下，这可能会导致意外结果。

[`-i`](#i) extension

与 `-I` 类似地就地编辑文件，但将每个文件与其他文件分开处理。 特别是每个文件中的行号从 1 开始， “$” 地址匹配当前文件的最后一行，地址范围仅限于当前文件。 （参见 [Sed A地址 。](#Sed_A__u5730___u5740____u3002_)) 最终结果就像每个文件都由单独的 `sed` 实例编辑。

[`-l`](#l)

使输出线缓冲。

[`-n`](#n)

默认情况下，每行输入都会在应用所有命令后回显到标准输出。 `-n` 选项会抑制这种行为。

[`-r`](#r)

与 `-E` 相同以与 GNU sed 兼容。

[`-u`](#u)

使输出无缓冲。

`sed` 命令的格式如下：

`[address[,address]]function[arguments]`

可以在命令的第一个地址和函数部分之前插入空格。

通常， `sed` 循环地将一行输入（不包括其终止换行符）复制到 _pattern space_ 中（除非在 “D” 函数之后留下一些东西），应用所有具有选择该模式空间的地址的命令，复制模式空间到标准输出，附加一个换行符，并删除模式空间。

一些函数使用 _hold space_ 来保存全部或部分模式空间以供后续检索。

[Sed 地址](#Sed___u5730___u5740_)
===============================

地址不是必需的，但如果指定，则必须具有以下格式之一：

*   一个数字，它在输入文件中累积计算输入行（或者如果 `-i` 选项有效，则在每个文件中独立）；
*   一个美元 (“$”) 字符，用于处理输入的最后一行（如果指定了 `-i` 选项，则为当前文件的最后一行）；
*   一个上下文地址，由一个正则表达式组成，前后有一个分隔符。 结束定界符后面也可以选择跟随 “I” 字符，以指示以不区分大小写的方式匹配正则表达式。

没有地址的命令行选择每个模式空间。

具有一个地址的命令行选择与该地址匹配的所有模式空间。

具有两个地址的命令行选择一个包含范围。 此范围从与第一个地址匹配的第一个模式空间开始。 范围的结尾是与第二个地址匹配的下一个模式空间。 如果第二个地址是小于或等于第一次选择的行号的数字，则仅选择该行。 第二个地址中的数字可以以 (“+”) 为前缀，以指定在第一个模式之后要匹配的行数。 在第二个地址是上下文地址的情况下， `sed` 不会将第二个地址与匹配第一个地址的模式空间重新匹配。 从所选范围之后的第一行开始， `sed` 再次开始寻找第一个地址。

通过使用感叹号 (“!”) 功能，可以将编辑命令应用于未选择的模式空间。

[Sed 正则表达式](#Sed___u6B63___u5219___u8868___u8FBE___u5F0F_)
==========================================================

默认情况下， `sed` 中使用的正则表达式是基本正则表达式（BRE，有关更多信息，请参阅 re\_format(7) ），但如果给出 `-E` 标志，则可以使用扩展（现代）正则表达式。 此外， `sed` 对正则表达式还有以下两个补充：

1.  在上下文地址中，除反斜杠 (“\\”) 或换行符之外的任何字符都可用于分隔正则表达式。 除非是斜杠，否则开头的分隔符需要以反斜杠开头。 例如，上下文地址 `\xabcx` 等价于 `/abc/` 。 此外，在正则表达式中的定界字符之前放置一个反斜杠字符会导致该字符被逐字处理。 例如，在上下文地址 `\xabc\xdefx` 中，RE 分隔符是一个 “x” ，第二个 “x” 代表它自己，所以正则表达式是 “abcxdef” 。
    
2.  转义序列 \\n 匹配嵌入在模式空间中的换行符。 但是，您不能在地址或替换命令中使用文字换行符。

`sed` 正则表达式的一个特殊功能是它们可以默认为最后使用的正则表达式。 如果正则表达式为空，即仅指定了分隔符，则使用最后遇到的正则表达式。 最后一个正则表达式被定义为用作地址或替代命令的一部分的最后一个正则表达式，并且在运行时，而不是编译时。 例如，命令 “/abc/s//XXX/” 将用 “XXX” 代替模式 “abc” 。

[Sed 函数](#Sed___u51FD___u6570_)
===============================

在以下命令列表中，每个命令允许的最大地址数由 \[0addr\]、\[1addr\] 或 \[2addr\] 表示，分别表示零、一个或两个地址。

参数 _text_ 由一行或多行组成。 要在文本中嵌入换行符，请在其前面加上反斜杠。 文本中的其他反斜杠被删除，下面的字符按字面意思理解。

“r” 和 “w” 函数带有一个可选的文件参数，它应该与函数字母之间用空格隔开。 每个作为 `sed` 参数的文件都是在任何输入处理开始之前创建的（或截断其内容）。

“b”, “r”, “s”, “t”, “w”, “y”, “!” 和 “:” 函数都接受附加参数。 以下概要指示哪些参数必须通过空格字符与函数字母分开。

其中两个函数采用函数列表。 这是由换行符分隔的 `sed` 函数列表，如下所示：

{ function function ... function } 

“{” 可以在空格之前，也可以在空格之后。 函数前面可以有空格。 终止的 “}” 必须以换行符开头，也可以以空格开头。

\[2addr\] function-list

仅在选择模式空间时执行功能列表。

\[1addr\]a\\

text

在每次尝试读取一行输入之前立即将 _text_ 写入标准输出，无论是通过执行 “N” 函数还是通过开始新的循环。

\[2addr\]b\[label\]

分支到具有指定标签的 “:” 函数。 如果未指定标签，则跳转到脚本的末尾。

\[2addr\]c\\

text

删除模式空间。 使用 0 或 1 地址或在 2 地址范围的末尾，将 _text_ 写入标准输出。

\[2addr\]d

删除模式空间并开始下一个循环。

\[2addr\]D

通过第一个换行符删除模式空间的初始段并开始下一个循环。

\[2addr\]g

将模式空间的内容替换为保持空间的内容。

\[2addr\]G

将换行符后跟保持空间的内容附加到模式空间。

\[2addr\]h

用模式空间的内容替换保持空间的内容。

\[2addr\]H

将换行符后跟模式空间的内容附加到保留空间。

\[1addr\]i\\

text

将 _text_ 写入标准输出。

\[2addr\]l

（字母 ell。）以视觉上明确的形式将模式空间写入标准输出。 该表格如下：

backslash

\\\\

alert

\\a

form-feed

\\f

carriage-return

\\r

tab

\\t

vertical tab

\\v

对于字符中的每个字节（最高有效字节在前），不可打印字符被写为三位八进制数（前面带有反斜杠）。 长行被折叠，折叠点通过显示反斜杠后跟换行符来指示。 每行的结尾都用 “$” 标记。

\[2addr\]n

如果默认输出没有被抑制，则将模式空间写入标准输出，并将模式空间替换为下一行输入。

\[2addr\]N

将下一行输入附加到模式空间，使用嵌入的换行符将附加的材料与原始内容分开。请注意，当前行号会发生变化。

\[2addr\]p

将模式空间写入标准输出。

\[2addr\]P

将模式空间，直到第一个换行符写入标准输出。

\[1addr\]q

分支到脚本的末尾并退出而不开始新的循环。

\[1addr\]r file

在下一次尝试读取输入行之前将 _file_ 的内容复制到标准输出。 如果由于任何原因无法读取 _file_ ，它会被静默忽略并且不设置错误条件。

\[2addr\]s/regular expression/replacement/flags

用替换字符串替换模式空间中正则表达式的第一个实例。 可以使用除反斜杠或换行符以外的任何字符代替斜杠来分隔 RE 和替换。 在 RE 和替换中，如果 RE 分隔符前面有反斜杠，则它本身可以用作文字字符。

替换中出现的和号 (“&”)-
被匹配 RE 的字符串替换。 在这种情况下， “&” 的特殊含义可以通过在它前面加一个反斜杠来抑制。 字符串 “\\#”, 其中 “#” 是一个数字，被相应的反向引用表达式匹配的文本替换（参见 re\_format(7) )。

可以通过在其中替换换行符来拆分行。 要在替换字符串中指定换行符，请在其前面加上反斜杠。

替代函数中 _flags_ 的值是以下零个或多个：

N

仅对模式空间中第 N 次出现的正则表达式进行替换。

g

替换正则表达式的所有非重叠匹配，而不仅仅是第一个。

p

如果进行了替换，则将模式空间写入标准输出。 如果替换字符串与它所替换的字符串相同，则仍将其视为已替换。

w _file_

如果进行了替换，则将模式空间附加到 _file_ 中。 如果替换字符串与它所替换的字符串相同，则仍将其视为已替换。

i or I

以不区分大小写的方式匹配正则表达式。

\[2addr\]t \[label\]

如果自最近读取输入行或执行 “t” 函数后进行了任何替换，则跳转到带有标签的 “:” 函数。 如果未指定标签，则跳转到脚本的末尾。

\[2addr\]w _file_

将模式空间附加到 _file_ 中。

\[2addr\]x

交换模式的内容并保留空格。

\[2addr\]y/string1/string2/

将模式空间中 _string1_ 中出现的所有字符替换为 _string2_ 中的相应字符。 可以使用反斜杠或换行符以外的任何字符代替斜杠来分隔字符串。 在 _string1_ 和 _string2_ 中，后跟除换行符之外的任何字符的反斜杠是该文字字符，并且后跟 “n” 的反斜杠被换行符替换。

\[2addr\]!function

\[2addr\]!function-list

仅将函数或函数列表应用于地址 _not_ 选择的行。

\[0addr\]:label

这个函数什么都不做；它带有一个标签， “b” 和 “t” 命令可以分支到该标签。

\[1addr\]=

将行号写入标准输出，后跟换行符。

\[0addr\]

空行被忽略

\[0addr\]#

“#” 和该行的其余部分被忽略（视为注释），唯一的例外是如果文件中的前两个字符是 “#n”, 则默认输出被抑制。 这与在命令行上指定 `-n` 选项相同。

[环境](#__u73AF___u5883_)
=======================

`COLUMNS`, `LANG`, `LC_ALL`, `LC_CTYPE` 和 `LC_COLLATE` 环境变量会影响 `sed` 的执行，如 environ(7) 中所述。

[退出状态](#__u9000___u51FA___u72B6___u6001_)
=========================================

The `sed` utility exits 0 on success, and >0 if an error occurs.

[实例](#__u5B9E___u4F8B_)
=======================

从另一个命令通过管道传输时，将 ‘`bar`’ 替换为 ‘`baz`’ :

echo "An alternate word, like bar, is sometimes used in examples." | sed 's/bar/baz/' 

使用反冲有时很难阅读和理解：

echo "/home/example" | sed 's/\\/home\\/example/\\/usr\\/local\\/example/' 

使用路径时使用不同的分隔符会很方便：

echo "/home/example" | sed 's#/home/example#/usr/local/example#' 

将文件 test.txt 中所有出现的 ‘`foo`’ 替换为 ‘`bar`’ ，而不创建文件的备份：

sed -i '' -e 's/foo/bar/g' test.txt 

[参见](#__u53C2___u89C1_)
=======================

awk(1), ed(1), grep(1), regex(3), re\_format(7)

[标准](#__u6807___u51C6_)
=======================

`sed` 实用程序有望成为 IEEE Std 1003.2 (“POSIX.2”) 规范的超集。

`-E`, `-I`, `-a` 和 `-i` 选项， `-f` `-` 的特殊含义，地址范围的第二个成员中的前缀 “+” ，以及地址正则表达式的 “I” 标志和替换命令是非标准的 FreeBSD 扩展，可能在其他操作系统上不可用。

[历史](#__u5386___u53F2_)
=======================

由 L. E. McMahon 编写的 `sed` 命令出现在 Version 7 AT&T UNIX 中。

[作者](#__u4F5C___u8005_)
=======================

Diomidis D. Spinellis <[dds@FreeBSD.org](mailto:dds@FreeBSD.org)\>

[缺陷](#__u7F3A___u9677_)
=======================

包含值为 0x5C (ASCII ‘`\`’) 的字节的多字节字符可能会被错误地视为 “a”, “c” 和 “i” 命令的参数中的行继续字符。 多字节字符不能用作 “s” 和 “y” 命令的分隔符。

June 10, 2020

FreeBSD 13.1-RELEASE